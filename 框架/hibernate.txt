

获取sessionFactory对象

从sessionFactory中取得session

取得trancaction开始事务，beginTrancaction()

用session执行查询
	1.用Criteria对象进行标准查询
		Criteria cr=s.createCriteria(Spittle.class);
		userlist=cr.list()
	或
	2.通过hql语句查询
		String hql=“from 持久类类名”
		Query q=Session.createQuery(hql)
		q.list()
	或
	3.用sql语句查询
	
trancaction 提交事务或回滚
	session在trancaction提交或回滚时，由hibernate框架管理关闭，我们不用手动关闭session
	
	同一id的数据库对象在一次事务中只能存在一个
	？？为什么我们没有自己关闭session
		hibernate框架会维护这个session，他会在你事务提交的时候关闭session。

Hibernate 架构	
	1.Configuration对象
		表示Hibernate的配置包括实体类映射配置(Entity.hbm.xml),和数据库配置(hibernate.cfg.xml / hibernate.porperties)
		包含两种组件
			数据库连接(hibernate.cfg.xml / hibernate.porperties)
				用以配置数据库链接
			实体类映射
				用于配置java对象与数据库的映射
	2.sessionFactory对象
		线程安全的，由Configuration对象创建，SessionFactory 在同一个application中一般只有一个，
		一个SessionFactory对应一种数据库的配置
	3.Session对象
		Session对象用于保存和检索持久化对象，与数据库进行交互
		Session由SessionFactory对象创建
	4.Transaction对象
		一个事务代表了与数据库工作的一个单元，进行数据库事务commit或rollback
		在 Hibernate 中事务由底层事务管理器（transactionManager）和事务(transaction)（来自 JDBC 或者 JTA）处理
	5.Criteria对象
		用于创造与执行面向规则的对象 来查询对象
	6.Query对象
		使用SQL或HQL执行CRUD操作
		
	Session接口　
		Session接口负责执行被持久化对象的CRUD操作,是非线程安全的
	SessionFactory接口　
		SessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建Session对象。一个项目通常只需要一个SessionFactory
	Configuration接口　
		Configuration接口负责配置并启动Hibernate，创建SessionFactory对象。
		
	上下文相关的会话（Contextual Session）
		特定的会话在整个特定的上下文范围内始终有效。就是session的运行环境，Session的上下文可以是一个Transaction的范围，可以是一个线程的范围，等等
		session在这些上下文范围内有效
		
		hibernate 3.0.1 版本开始，Hibernate 增加了 SessionFactory.getCurrentSession()，默认用JTA定义Session的上下文。
		
		hibernate 3.1 开始 新的扩展接口（org.hibernate.context.CurrentSessionContext）和新的配置参数（hibernate.current_session_context_class）
		，session的范围与上下文的定义可以实现热拔插了，随时可换上下文
		也就是说可以通过current_session_context_class参数去灵活定义Session的上下文
		current_session_context_class 配置参数定义了应该采用哪个 org.hibernate.context.CurrentSessionContext 实现。
			参数的值指明了要使用的实现类的全名
			可以用"jta"、"thread" 和 "managed"3个简写分别对应内置的3个Context


配置
	1 Configuration
		用来构建一个（不可变的（immutable））org.hibernate.SessionFactory
		实例化一个Configureation对象
		1.指定 XML 映射定义文件
			addSource("***.xml")
			addSource(***.class)
			或在配置文件上<mapping>配置映射
			或直接通过注解扫描配置映射
		2.指定配置属性
			setProperty("hibernate.dialect","org.hibernate.dialect.MySQLInnoDBDialect")
			或在hibernate.cfg.xml/hibernate.properties配置文件上配置属性
		
	2 SessionFactory
		SessionFactory被应用的所有线程共享
		3.通过Configuration对象的取得SessionFactory
			Configureation.buildSessionFactory();
			
	3 Session（取得jdbc连接）
		前提是配置好数据源或JDBC
		4. SessionFactory.openSession()
			SessionFactory会从连接池获得一个连接
			
			1.hibernate.connection.pool_size 是hibernate自带的，可用c3p0连接池替代
			在hibernate.connection.pool_size的位置用c3p0的配置替代即可
				hibernate.connection.driver_class = org.postgresql.Driver
				hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
				hibernate.connection.username = myuser
				hibernate.connection.password = secret
				hibernate.c3p0.min_size=5
				hibernate.c3p0.max_size=20
				hibernate.c3p0.timeout=1800
				hibernate.c3p0.max_statements=50
			如果设置了 hibernate.c3p0.* 相关的属性，Hibernate将使用 C3P0ConnectionProvider 来缓存 JDBC 连接
			
			1.配置成从注册在 JNDI 中的 Datasource 处获得连接
				属性
					hibernate.connection.datasource = java:/comp/env/jdbc/test
					hibernate.connection.datasource	数据源 JNDI 名字
					
			1.通过实现 org.hibernate.connection.ConnectionProvider 接口，定义属于你自己的获得JDBC连接的插件策略
				hibernate.connection.provider_class，选择一个自定义的实现类，为hibernate提供jdbc连接
		
	4可选的配置属性
		常用:	
			Hibernate 配置属性
				hibernate.dialect					//允许 Hibernate 针对特定的关系数据库生成优化的 SQL
				hibernate.show_sql				//输出所有 SQL 语句到控制台
				hibernate.session_factory_name		//SessionFactory 创建后，将自动使用这个名字绑定到 JNDI 中。 
				hibernate.default_batch_fetch_size		//为 Hibernate 关联的批量抓取设置默认数量。例如：建议的取值为 4，8，和 16 
			
			JDBC 和连接（connection）相关属性
				hibernate.default_batch_fetch_size 		//关联的批量抓取设置，建议的取值为 4，8，和 16，就是每次从关联记录中去多少记录 int
				hibernate.jdbc.fetch_size			//指定每次从JDBC抓取数量的大小（调用 Statement.setFetchSize()）	int
				hibernate.jdbc.batch_size			//允许 Hibernate 使用 JDBC2 的批量更新,即hibernate每产生n条更新语句，就向JDBC提交一批语句
				hibernate.connection.provider_class		//指定自定义的Connection提供类，向Hibernate提供JDBC链接	Class
				
			Hibernate 缓存相关属性
				hibernate.cache.provider_class		//指定自定义的CacheProvider的类名,为hibernate提供二级缓存 ：Class
				hibernate.cache.use_query_cache		//允许查询缓存，个别查询仍然需要被设置为可缓存的。例如：true | false 
				hibernate.cache.use_second_level_cache	//允许二级缓存，对那些在类的映射定义中指定 <cache> 的类，会默认开启二级缓存。 
				
			Hibernate 事务属性
				hibernate.transaction.factory_class		//一个 TransactionFactory 的类名，用于 Hibernate Transaction API（默认为 JDBCTransactionFactory）。
				
			其他属性
				hibernate.current_session_context_class	//自定义session的上下文 例如：jta | thread | managed | custom.Class 
				hibernate.query.factory_class			//选择HQL解析器的实现
				hibernate.hbm2ddl.auto				//| validate 	验证创建数据库表结构，若实体类与表结构不同，就报错
											//| update 		只是更新数据不会更改表结构,即删除表后会恢复
											//| create 		每次加载hibernate，如果数据库中存在表，将所有表删除，然后重新生成表
											//| create-drop	加载hibernate时创建，退出时删除表结构，数据库中原本有几个表就有几个表
											
			 
			JNDI 绑定的 SessionFactory

			

事务
	session的begainTransaction（）过程
		首先在cfg.xml的SessionFactory中定义的hibernate.transaction.factory_class，指定了谁提供事务给Session
		然后，由session所在的上下文(context),决定是否创建一条transaction
			若session所在的上下文已经有hibernateTransaction的一个实例则直接返回这条事务
			若session所在的上下文已经没有hibernateTransaction实例
				则由上下文取得transactionFactory的引用，并创建一个hibernateTransaction实例返回给session
		
		session――――――>beginTrransaction――――>getTransaction----->begin---->return to session
								   ||
								   V
								   context---->getTransaction----transaction!=null---->return transaction
												    |-----transaction=null----->gettransactionFactory
																		|------>createTransaction----->return transaction 
		hibernate的transactionFactory有3种
	事务策略配置
		org.hibernate.Transaction统一了各种事务的具体实现，可方便决定用哪种事务
		通过设置 Hibernate 配置属性 hibernate.transaction.factory_class 来指定一个 Transaction 实例的工厂类，
		用来产生transaction,决定session用谁的transaction来对数据库操作
		有三个标准（内建）
			默认用org.hibernate.transaction.JDBCTransactionFactory
				使用JDBC事务的工厂，即本地事务
			org.hibernate.transaction.JTATransactionFactory
				使用JTA事务的工厂
				如果在上下文环境中存在运行着的事务（如，EJB 会话 Bean 的方法），则委托给容器管理的事务。
				否则，将启动一个新的事务，并使用 Bean 管理的事务。
			org.hibernate.transaction.CMTTransactionFactory
				使用容器管理的事务的工厂，
				事务的开始、提交、回滚交给容器决定，
			
持久化类
	
	实体类定义要求
		1.普通的pojo类(可以是一个接口，然后用<subclass> 来指定该接口的实际实现类。)，要有唯一的id作为主键
			！！！若主键设置为自动生成，那么新增记录时，id不能自己给，由数据库生成，若数据库没设置为唯一标识，不会自动生成主键
			！！！报主键不能为null错误，要在数据库配置id为主键标志--是
		2.实体类必需要有一个默认的构造方法
			因为hibernate通过 反射机制 创建实体类的实例
			
	继承
		子类也必须遵守第一条和第二条规则。它从超类 Cat 继承了标识属性
		
	实现 equals() 和 hashCode() 方法
		想把持久类的实例放入 Set 中（当表示多值关联时，推荐这么做），而且想重用脱管实例
		就要实现这两个方法，用于比较两数据库行形成的实体类是否等价，被添加到 Set，则在 Set 中只有一个元素
		实现方法:业务键值相等
			equals() 方法仅仅比较形成业务键的属性，即比较各列属性
		Hibernate 仅对那些持久化对象赋标识值
		
	动态模型
		hibernate的持久化实体不仅可以是POJO类，也可以映射成Map或Dom4j树模型
		映射配置
			将映射文件<class>声明 entity-name 来代替一个类名，使数据库的一个行映射成map，
			在程序运行时就可以用map来代替实体类
			
	3种状态
		瞬时态
			一个被new实例化的javaPOJO对象，并未与Session关联，在数据库中无记录
		持久态(被绑定到Session上的对象)
			Session用save。saveOrUpdata方法处理瞬时态的对象，那么该对象就变为持久态，
			或者session用Criteria从数据库检索一条记录并映射成一个java对象时，这个java对象是持久态的
			
			对处于持久态的对象的任何操作都会被Hibernate 监视任何改变并在后台隐式写的方式执行SQL，放在session的缓存区
			当Session flush的时候，就会同步内存状态（缓存）和数据库
		脱管态
			从持久太脱离出来的不再与Session关联的对象，此时对对象的任何操作都不会记录进数据库
			session对脱管态对象用updata，使其重新变为持久态，只有用updata才能对对象在脱管态时的改动持久化到数据库

对象/关系数据库映射基础		
	通过映射文件配置映射
		映射文件为***-hbm.xml
		<hibernate-mapping>
			<class name="javapojo"  table="usertable"> //javapojo类与usertable间的映射
				<id type=“int”> //主键映射，type指定类型
			O/R映射 
				<property>//非主键映射
			集合映射	(一切集合都是表)
				若pojo中有集合属性
					用<set>、<list>、<bag>，<map>与数据库的集合类字段建立映射
					set,list,collection,map
				值类型
					java中的基本元素类型int string。。。。
				值类型集合
					普通类型的集合
					<set name="emailAddresses" table="PERSON_EMAIL_ADDR">//该集合属性对应的关联表
						<key column="PERSON_ID"/>				//persion类在关联表对应的字段
						<element type="string" column="EMAIL_ADDR"/>	//基本元素类型的集合用<element>定义，column指定表中与Persion关联的字段，”string“是向你表明它是一个 Hibernate 的映射类型
					</set>									//包含的是String类型的集合
			
			关联映射 1-1 1-* *-1 *-*
				<many-to-one name=“father”></many-to-one>//与<porperty>差不多
				单向关联映射
					一个实体类与另一个实体类有关联，且他们关系是	
				单向 多对多关联(只要在一个实体类中设置关联映射)
					n:m实体关联需要一个关联表，
					由<set>元素的table属性指定映射的关联表
					<set>里的<key>元素表明当前实体类对应的是关联表的哪个标识符字段名
					而 event 一端的字段名是由 <many-to-many> 元素的 column 属性定义
					<set name="events" table="PERSON_EVENT">		//persion实体类的events集合属性对应着PERSON_EVENT这个关联表
						<key column="PERSON_ID"/>			//persion实体类对应的是关联表里的PERSON_ID字段
						<many-to-many column="EVENT_ID" class="Event"/>//关联表里的EVENT_ID字段对应的是Event实体类，并且Persion类与Event类是多对多关联的
					</set>								//包含的是实体类的集合
				双向 多对多关联(要在关联两边的实体类中都设置关联映射)
					<set name="participants" table="PERSON_EVENT" inverse="true">//event实体类的participants集合属性对应着PERSON_EVENT这个关联表
						<key column="EVENT_ID"/>			//persion实体类对应的是关联表里的PERSON_ID字段
						<many-to-many column="PERSON_ID" class="Person"/>//关联表里的PERSON_ID字段对应的是Person实体类，并且event类与persion类是多对多关联的
					</set>								//包含的是实体类的集合
					 Event 映射文件里增加了 set 元素的 inverse="true" 属性。 这意味着在需要的时候，Hibernate 能在关联的另一端 ― Person 类得到两个实体间关联的信息。
				
				单对多关联
					<set name="pages">						//pages集合的关系映射
						<key name="OwnerId">				//对应pageItem中的OwnerId
						<one-to-many class="PageItem">			//每个user对应多个PageItem
				
				总结:！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
					映射文件中在<set>等集合元素配置的 必需是*对多关联 ，因集合变量存放多个关联的对象
					不在<set>等集合元素中配置的关联  只能是*对一关联 ，因一个非集合变量只存放一个关联对象
					单向关联只要在关联的一端配置映射
					双向关联要在关联的两端都配置映射，且要在多的一端配置inverse=“true”属性
					必要时table属性指明保存两者关联关系的那个表
					*对多关联中，<key>表示‘我‘在关联表中是哪个列,class属性表示关联的是哪个实体
			组件映射 对应数据库中与另一个表的关联
				属性是另一种实体类(组件类)，由另一种实体类构成当前的实体类(组件映射)
				如果引用的类没有自己的生命周期并且完全依靠于拥有它的那个实体类的生命周期的话，
				那么这个引用类因此就可以叫做组件类。
				<Component Mappings>
	----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	通过注释配置映射
		先导入依赖包hibernate-annotations.jar, lib/hibernate-comons-annotations.jar 和 lib/ejb3-persistence.jar
		类级注释
			@SubSelect（“SQL”）
				子查询，形成一个视图，hibernate从该视图中查询
			@Entity
				在类上使用表示该类为持久类
				被注释的类要有一个没有参数的构造函数并且在可保护范围是可见
			@Table(name = "EMPLOYEE")
				在持久类上使用表示该持久类映射的表“EMPLOYEE”
			
			@OptimisticLocking (type = OptimisticLockType.ALL)  保证数据在某个操作过程中不会被外界修改
			public class EmployeeEntity implements Serializable 
				type:
					version（版本检查）：只检查 version/timestamp 字段,检查@javax.persistence.Version
					all（全部）：检查全部字段
					dirty（脏检查）：只检察修改过的字段，允许某些并行更新
					none（不检查）：不使用乐观锁定
				建议对version/timestamp 字段来进行乐观锁定。这个选择可以优化性能
				在version/timestamp属性上@Version，使之成为数据状态标识
			
			@synchronize
				定义这个实体所用的表为同步（synchronize），确保自动刷新（auto-flush）正确执行，并且依赖原实体的查询不会返回过期数据
			
			@AttributeOverrides({		//在子类上使用时，将重写父类属性到表的映射字段
							  @AttributeOverride(name="key.street1", column=@Column(name="fld_street")),
							  @AttributeOverride(name="value.stars", column=@Column(name="fld_note"))
						   })
						   
			@MappedSuperClass
				在父类上使用，使子类继承父类的所有字段，在子类上可以用@AttributeOverride重写字段映射
					可选在父类上声明数据库标识符
				
			@lazy
				延迟加载（Lazy fetching）
				
			@entity-name（default=classname）map、xml
				决定将实体映射成什么 ：类 or Map or Xml
			
			@subclass
				为接口的持久类指定实现类
		成员级注释
			@Id 和 @GeneratedValue 
				属性
					column:指定主键字段的名字
				@id注明的属性是表中的主键，主键可以是一个字段或者是多个字段的组合，这取决于你的表的结构。
				@GeneratedValue自动生成主键
				
			@Column
				指定某个属性与数据库某个字段的映射
					name 属性允许显式地指定列的名称。
	
	！映射定义（Mapping declaration）
		1实体
			@Entity
				在类上使用表示该类为持久类
				被注释的类要有一个没有参数的构造函数并且在可保护范围是可见
		
		2标识符Identifiers
			@id
				指定某成员属性为id，类型为基本类型的包装类
				
			复合主键
				@EmbeddedId
					指定类型为某个@Embeddable类的属性为id
					
				@Embeddable
					把某个类声明为可嵌入的，用来做嵌入id
			
			id生成器
				@GeneratedValue	//默认jpa自动生成值，由数据库来生成值，要在数据库配置
				或
				@GeneratedValue(generator="tor")	//配置生成器
				@GenericGenerator(name="tor",strategy="sequence",pamarter={})//用hibernate定义id生成器
				
			
		3乐观锁定的属性 为了防止同一实体类被不同的会话更新到数据库
			一个脱管（detached）实例的 version 或 timestamp 属性不能为空（null）
			要定义一个不能为空的 version 或 timestamp 属性
			
			Version number
				@Version				
					使用指定某属性为版本号		//对应表上的一个数值类型的version列
				参数
					column="version_column"				//指定持有版本号的字段名
					name="propertyName"
					type="typename"						//默认是integer，版本号的类型
					access="field|property|ClassName"
					unsaved-value="null|negative|undefined"		//用于标明某个实例时刚刚被实例化的（尚未保存）版本属性值
					generated="never|always"				//表明此版本属性值是否实际上是由数据库生成的
					insert="true|false"
					node="element-name|@attribute-name|element/@attribute|."
					
			timestamp						//对应表上的一个日期类型的timestamp列
				@Version	//注解方式同样用@version，不过type只能是Date or Calendar
					type类型为Date or Calendar
				或
				<timestamp
						column="timestamp_column"				//存有时间戳的字段名,默认是属性名
						name="propertyName"
						access="field|property|ClassName"
						unsaved-value="null|undefined"
						source="vm|db"
						generated="never|always"				//指出时间戳值是否实际上是由数据库生成的
						node="element-name|@attribute-name|element/@attribute|."
				/>
		
		4普通字段 Property
			@Transient
				表示该属性不是表中的字段，只是用来临时使用的，不会持久化到数据库
			@Basic
				属性的默认注解，即未加@Column的属性，对应表的字段，fetch = FetchType.LAZY用来设置懒加载
			@Lob 
				注解属性将被持久化为(byte log)Blog 或 (char lob)Clob 类型，Byte[], char[] ,存放大数据的类型
				@Basic、lob、column
				int getLength()
			@type(type="")
				为属性指定类型 可以使基本类型integer, string, character,date, timestamp, float, binary, serializable, object, blob
				或复合类型
				或一个可以序列化的 Java 类的名字。
			@Column
				name="columnname"	//指定该属性映射的字段名
				nullable = false		//是否可以为null
			@Formula(value="(select count(p.PageId) from pagetable p where p.OwnerId=id)")
				当hibernate访问数据库时，执行该SQL语句并将查询值赋值给被注解的属性
			组件
				组件类的属性约束只能在Column中用nullable添加
				将某类定义为组件并声明为实体类的组件属性，是值类型
					@Embeddable
						将类声明为复合类（组件），有多个属性
						可指定@Column属性设置列的相关属性，按照我们设定的值去生成表的字段
					@Embedded
						在一个属性中使用复合（组件）类型
						@AttributeOverrides
							在@Embedded属性中使用，覆盖@Embeddable的列属性，包含多个@AttributeOverride
						@AttributeOverride
							 @AttributeOverride(name="city", column = @Column(name = "person_city", length = 15))})
							 定义如何覆盖@Embeddable类的属性，
							 name	//指明覆盖的属性名
							 column	//指明被覆盖的属性映射成表中的什么字段名
						@AttributeOverrides({
							  @AttributeOverride(name="key.street1", column=@Column(name="fld_street")),
							  @AttributeOverride(name="value.stars", column=@Column(name="fld_note"))
						   })	
					组件可嵌套
					xml
						<component name="name" class="Name" unique="true">
						//name 	实体类中的组件属性名
						//class	组件的类名
							<parent name="owner"/>
							<property name="first" />
							<property name="last" />
						</component>
					
			xml
				<property
					name="propertyName"		//属性的名字
					column="column_name"		//对应的数据库字段名，或用<column>标签进行详细的属性配置
					type="typename"			//一个 Hibernate 类型的名字
					update="true|false"
					insert="true|false"
					formula="arbitrary SQL expression"
					access="field|property|ClassName"
					lazy="true|false"		//指定实例变量第一次被访问时，这个属性是否延迟抓取
					unique="true|false"		//使用 DDL 为该字段添加唯一的约束
					not-null="true|false"		//使用 DDL 为该字段添加可否为空（nullability）的约束
					optimistic-lock="true|false"	//指定这个属性在做更新时是否需要获得乐观锁
					generated="never|insert|always"//表明此属性值是否实际上是由数据库生成的
				/>
	!映射继承关系
		@AttributeOverrides({		//在子类上使用时，将重写父类属性到表的映射字段
							  @AttributeOverride(name="key.street1", column=@Column(name="fld_street")),
							  @AttributeOverride(name="value.stars", column=@Column(name="fld_note"))
						   })
		1:@MappedSuperClass
			在父类上使用，使子类继承父类的所有字段，在子类上可以用@AttributeOverride重写字段映射
				可选在父类上声明数据库标识符id
		或			
		每个子类各有一个表
		2:@Entity+@Inheritance(strategy="Table_Per_Class")
			在父类上使用，使子类继承父类的所有字段,
				从不同的子表select出需要的字段通过union 子表 as 父表
			！！用这种方法，必需要在父类上定义数据库标志符，所有子类共享标志符
			这种策略的子类的表之间没有关系，互不关联，子类表还是独立的，父类表是通过子表的union操作构成的
		或
		所有子类公用一个父类表		//不推荐
		3:@Entity+@Inheritance(strategy="Single_table")
			在父类上使用，使子类继承父类的所有字段,
			！！用这种方法，必需要在父类上定义数据库标志符，所有子类共享标志符
			要父类配置识别器@DiscriminatorColumn(name="By_TYPE") //用于识别不同的子表的识别值，来区分子表
			同时在子类上用@DiscriminatorValue（"CC"）		//为子表赋予一个不同的识别值
		或
		4:@Entity+@Inheritance(strategy="Inheritancetype.joined")
			在父类上使用，使子类继承父类的所有字段, 通过联结的形式(inner join),构成表
				父表 inner join 不同的子表	= 父表
			！！用这种方法，必需要在父类上定义数据库标志符，所有子类共享标志符
			子类表引用父表的外键约束，可用@PrimaryKeyColumn指定外键列作主键
	
		
	！Hibernate 的类型 
		实体（Entities）和值（values）
			实体的持久状态包含指向其他实体和值类型实例的引用，实体有独立标识，对应数据库中的一个表
			值对象是随着包含他们的实体而被持久化和删除的，值没有独立的标识，不对应表，是实体属性的成分
			组件就是用户自定义类，却是值语义的，属于值类型，组件随实体类被持久化和删除
		基本值
			integer,long,float,double,character,byte,boolean,yes_no,true_false
			String--->VARCHAR
			java.util.Date----->time,timestamp,data
			BigDecimal ,BigInteger------>NUMERIC
			binary字节数组----->SQL 二进制类型
		组件类型（Composite types）
		集合类型 Collection types
		实体类型Entity types
	
	！多次映射同一个类
		指定 entity name 来区别不同映射实体的 对象实例，通过实例名多次映射
		<class name="Contract" table="Contracts"
        entity-name="CurrentContract">
	
	！集合映射		//在集合属性上使用
		1映射实体类集合
			@OneToMany
				一对多映射
				//不用连接表时，基于外键
					@JoinColumn(name="PART_ID")	
						//注释的是另一个表指向本表的外键字段。另一表的PART_ID为外键，本表是一 
					<set name="parts">
						<key column="productSerialNumber" not-null="true"/>//另一个表指向本表的外键字段
						<one-to-many class="Part"/>			//被关联的类名
					</set>
				//用连接表时，基于连接表
					@JoinTable(name="tableName"	
							 JoinColumns={@JoinColum(name="persion")}		//本表主键在中间表中对应的字段
							 inverseJoinColum=@JoinColumn( name="PART_ID")//另一个表主键在中间表中对应的字段
							)	
						//注释的是另一个表指向本表的外键字段。另一表的PART_ID为外键，本表是一 
					<set name="parts">
						<key column="productSerialNumber" not-null="true"/>//另一个表指向本表的外键字段
						<one-to-many class="Part"/>			//被关联的类名
					</set>
			@ManyToMany
				多对多映射必用连接表，基于连接表
					@JoinTable(name = "Person_Project",  	//中间表名
					joinColumns = {@JoinColumn(name = "person_id")},  //本表主键在中间表中对应的字段，即外键
					inverseJoinColumns = {@JoinColumn(name = "project_id")}) //另一个表主键在中间表中对应的字段 
					<set name="parts" table="tableName">
						<key column="productSerialNumber"/>//另一个表指向本表的外键字段，外键
						<many-to-many class="Part"/>			//被关联的类名
					</set>	
		
			集合外键（foreign keys）
				@JoinColumn(nullable=false)					//指定表中的外键是哪个字段，通过外键取得关联的对象
				或
				<key column="productSerialNumber" not-null="true"/>	
				
			索引集合
				@OrderBy("name")	//按照集合类的name属性作索引
				@OrderColumn(name="orders_index")	//用持有集合索引值的字段的名称
		
		2映射基础类型集合和组件类集合
			集合元素为基础类型的映射
				@ElementCollection			//声明该集合是基础类型的集合
				@CollectionTable(name="Nicknames", joinColumns=@JoinColumn(name="user_id"))//声明中间表和外键
				@Column(name="nickname")		//声明该集合在中间表对应的字段
				
			
			集合元素的类型为组件类的映射
				@ElementCollection
				@CollectionTable(name="Addresses", joinColumns=@JoinColumn(name="user_id"))//中间表为Address，外键是user_id
				@AttributeOverrides({
				@AttributeOverride(name="street1", column=@Column(name="fld_street"))	//组件类的street映射成中间表的fld_street字段
				})
				
			xml方式
				不用<*ToMany>标签，换成<element>标签
					<key column>		//指明保存关联的表的外键
					<element			//指明保存关联的表的主键
						column(1)="column_name"
						formul(2)a="any SQL expression"
						type="(3)typename"
						length="L"
						precision="P"
						scale="S"
						not-null="true|false"
						unique="true|false"
						node="element-name"
				/>
		高级
			有序集合
				@Sort
					用于SortSet或SortMap，对集合进行排序，
					
			双向关联 //双向关联允许通过关联的任一端访问另外一端
				在关联的两个类上都定意义*TO*
				一对多关联
					@OneToMany(MappedBy="d")
						MappedBy==xml的inverse=true	//定义了作为反向端的实体
					或
					<bag name="categories" table="CATEGORY_ITEM" inverse="true">
							<key column="ITEM_ID"/>		
							<one-to-many class="Category" column="CATEGORY_ID"/>
					</bag>
				
				多对多关联		//必需定义中间表table="CATEGORY_ITEM"，不定义则隐式使用表
					@ManyToMany(cascade = CascadeType.PERSIST，mappedBy=“”)
						MappedBy==xml的inverse=true	//定义了作为反向端的实体
					或
					<bag name="categories" table="CATEGORY_ITEM" inverse="true">
							<key column="ITEM_ID"/>		
							<many-to-many class="Category" column="CATEGORY_ID"/>
					</bag>
	！关联关系映射	//任何映射都要有name
		基于外键的单向关联
			一对多	//不推荐用外键关联，最好用连接表关联
				@OneToMany（cascaed）		//级联操作
				@JoinColumn（name="OwnerId"）//指明保存关联关系的表的外键，根据这外键取得集合
				or
				<set name="pages">
					<key column="OwnerId">	//外键
					<oneToMany class="pageItem">//只要指定类
				</set>
			一对一
				1@OneToOne
				2@JoinColumn（name="OwnerId"）	//两者关系通过外键-OwnerId-确认
				2@PrimaryKeyColumn				//或通过共享主键确定关联关系，外键=主键
				or
				<one-to-one name="page" >
			多对一	//与一对一关联相似
				@ManyToOne
				@JoinColum(name="OwnerId")		//两者关系通过外键-OwnerId-确认
				or
				<many-to-one name="Owner" Column="OwnerId">//可以指明通过哪个外键确定关联关系，不指定就默认为属性名作外键列名
		使用连接表的单向关联（jointable）	
			一对多	//不推荐用外键关联，最好用连接表关联
				@OneToMany（cascaed）		//级联操作
				@JoinTable（				
					name="tableName",		//指明保存关联关系的连接表名
					joinColumn=“”
				）
				or
				<set name="addresses" table="PersonAddress">
					<key column="personId"/>
					<many-to-many column="addressId"
						unique="true"
						class="Address"/>
				</set>
			一对一
				1@OneToOne
				2@JoinTable（				
					name="tableName",		//指明保存关联关系的连接表名
					joinColumn=“name”			//对于被关联类的外键
				）			
				or
				<one-to-one name="page" >
			多对一	//与一对一关联相似
				@ManyToOne
				@@JoinTable（				
					name="tableName",		//指明保存关联关系的连接表名
					joinColumn=“”
				）
				or
				<many-to-one name="Owner" Column="OwnerId">//可以指明通过哪个外键确定关联关系，不指定就默认为属性名作外键列名
				<join table="PersonAddress" 
					optional="true">
					<key column="personId" unique="true"/>
					<many-to-one name="address"
						column="addressId" 
						not-null="true"/>
				</join>
	!Inverse和Cascade的比较
		 Inverse：负责两个关联对象的控制关系
			决定谁控制谁的级联，false的一方作主控，true的一方被控
				若主控的一方被删除，被控的一方中所有与主控方有关的【外键字段】被清空赋值null
				被控方
			用于集合属性上
			MappedBy="parent"	= inverse=true+@JoinColum	//通过child的parent属性构成childs集合，parent作为主控端
			或									//集合的元素通过相同的parent映射而来
			inverse=true
				表示该集合的实体类是反向的，是被控方，
				相同 “d” / <key> 的记录形成了该集合
		 Cascade：负责控制关联对象的级联操作
			用在级联保存，级联更新，级联删除上
			决定主控一方的哪种操作会级联到被控一方
				若主控的一方被删除，被控的一方中所有与主控方有关的【记录】被整条删除
			级联删除(在OneToMany一端用)
				@OnDelete
				或
				<key column="productSerialNumber" on-delete="cascade"/>
				
会话	
	Session s=SessionFactory.getCurrentSession()
		SessionFactory会把当前当前java线程与一个Session对象绑定，调用getCurrentSession()时，会把当前线程绑定的Session对象返回
		cfg.xml中配置会话跟踪current_session_context_class 的值为thread 使session对象与在一条线程上活动，与一条线程绑定，
	session的生命周期
		当getCurrentSession()或openSession()获取一个session时，Session的生命周期开始
		当事务结束的时候，不管是提交还是回滚，Hibernate 会自动把 org.hibernate.Session 从当前线程剥离，并结束Session

查询
	Hibernate 查询语言（HQL）		感觉就是SQL语句，不过有所不同 ：***
		命名参数(:var)
			在HQL的中用 ：param 使用命名参数，在Query中为命名参数赋值
			或者直接用？
		聚合方法
			avg(),count().max(),min(),sum()
			
	Hibernate 标准查询 Criteria
		创建Criteria:
			session.creatCriteria()
		添加查询规则:
			Criteriaobj.add(Restrictions.eq(String,object))
			对标准的限制
				add(Restrictions类)
				Criteriaobj. add ( Restrictions.eq(String,object) )
			分页使用标准
				Criteria的setFirstResult（）与 setMaxResults
			排序结果
				add(Order类)
				Criteriaobj. add ( Order.desc("salary"))
			预测与聚合 对应与HQL的聚合方法
				Projections类
				Criteriaobj. setProjection ( Projections.avg("salsry"))
		获取查询结果
			cr.list()
		用于创造与执行面向规则的对象 来查询对象
	
	原生SQL语言查询

缓存
	有一级缓存与二级缓存，都存在于内存或硬盘
	默认下，Hibernate 将缓存所有的在会话层缓存中的持久的对象
	一级缓存
		保存在Session里的缓存，是一级缓存，是必需有的缓存，缓存只在当前Session有效
	二级缓存
		用第三方提供的缓存管理，是可选的缓存，
		第二级缓存可以在每一个类和每一个集合的基础上被安装，并且它主要负责跨会话缓存对象。 
		
		hibernate本身只提供二级缓存的规范，有第三方插件做具体实现。EHCache 
		
		Hibernate 配置二级缓存通过两步设置
			1.在配置文件hibernate.cfg.xml中	配置二级缓存提供者
				<property name="hibernate.cache.provider_class">
				  org.hibernate.cache.EhCacheProvider		//缓存提供者
			   </property>
					声明缓存提供者
					
			2.激活二级缓存
				<prop key="hibernate.cache.use_second_level_cache">true</prop>
			
	使用缓存
		1.使用配置文件中的 hibernate.cache.use_query_cache="true" 属性 	
				<property name="hibernate.cache.use_query_cache">true</property>
					激活查询层次缓存
					使用查询缓存:Query 类的 setCacheable(Boolean)
		2.在配置文件中决定好使用哪个并发策略
				Read-only 	Nonstrict-read-write 	Read-write 	Transactional
				在配置文件中配置<cache usage="read-write">	//在映射文件中配置
					表示使用并发策略  read-write
						<cache 
							usage="transactional|read-write|nonstrict-read-write|read-only"
							region="RegionName"
							include="all|non-lazy"/>
				
批处理
	启用批处理
		配置文件中配置每批大小
			<property name="hibernate.jdbc.batch_size">50</property> 
				告诉 hibernate 容器每 50 行sql语句为一批插入，删除，更新数据库
			
			hibernate.jdbc.fetch_size
				Fetch Size 是设定JDBC的Statement读取数据的时候每次从数据库中取出的记录条数
				合理配置，可减少对数据库的读取，加快了速度
		程序中
			每50条记录就执行一次session.flush() 和 session.clear()
			
		flush()
			将缓存区的缓存写入数据库
		clear()
			清空缓存区
		
	hibernate.jdbc.fetch_size 50 //读 读取时，每次从数据库取50条查询记录，50性能显著提升，100为提升阀值，》100无明显提升
	hibernate.jdbc.batch_size 30 //写 UCD操作时批量删除，批量更新和批量插入的时候的批次大小
		CUD 操作时Hibernate都会往二级缓存充入相应的数据。性能上就会有很大损失，建议在批处理情况下禁用二级缓存。
		
拦截器
	在session对数据库操作时，对其各个阶段进行拦截
	通过直接实现 Interceptor 类或者继承 EmptyInterceptor 类，使用拦截器