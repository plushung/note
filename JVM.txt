方法区（永久代）：存放class的元数据，和常量池，内容被永久保存，
	jdk8后被移除，用本地内存的元数据空间（metaspace）取代。类的元数据放入 native memory, 常量池和类的静态变量放入java堆中
堆区：存放数据对象
栈区：存放线程工作状态,存放每个要执行的方法，存放变量(引用)，调用函数时线程状态保存在棧区

垃圾回收机制
	java的内存管理使用自适应的垃圾回收技术:"标记-清除"+"停止-复制"
		自适应：
			当无用对象的内存碎片较少时，自适应地使用"标记-清除"法来进行垃圾回收
			当无用对象的内存碎片较多时，自适应地使用"停止-复制"法来进行垃圾回收
		
	查找'活'对象
		通过遍历堆栈区和静态存储区的引用，找出这些引用所指向的存活的对象。二次标记。
	
	实施清理算法
		停止-复制:（多无用内存时）
			在清除无用对象，释放内存前先停止程序运行，再执行清除工作
			缺点：
				浪费了一半的内存来做复制操作
			过程
				1.查找'活'对象
				2.将活的对象复制到内存中的新的堆上并合理排序		//复制过程中对对象进行了编排，所以清理后空闲的内存地址空间是连续的
				3.更新存活对象的引用
			
			适用
				因为是要停止程序和用复制的方式，频繁停止-复制会造成性能损失
				所以适用于无用对象比较多的情况
			
		标记-清除:（少无用内存时）
			不进行对象复制，只是对存活的对象进行标记，然后把没被标记到的对象的内存释放
			
			过程
				1.查找'活'对象，并标记
				2.清除没被标记对象的内存	//清理过程知识释放无用对象，所以清理后空闲的内存地址空间是不连续的
			
			适用
				因为是通过程序运行时标记对象的方式，不用暂停程序，在只有少量碎片时既可以保证程序性能，又能释放内存空间
				所以适用于无用对象比较少的情况
		
		标记-整理：	
			不直接清理可回收对象，将存活对象向一端移动，覆盖可清理对象，清理存活对象端边界外的内存，更新引用
			
		分代收集法（G1）：
			将java堆分为一系列年轻代和老年代区，不同区用不同GC算法（自适应）
			年轻代区域存活对象较少，使用Copy to Survivor（复制算法）
				将Eden和Servicor中的存活对象，复制到新的Survivor区，若新的Survivor不够大则复制到老年代区，完成GC
				Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）
			老年代区域存活对象较多，使用标记-整理进行GC
				老年代：主要存放应用程序中生命周期长的内存对象

垃圾收集器
	新生代都用复制算法清理
	老年带使用标记-整理算法清理
	serial：新生代，单线程
	parNew：新生代，多线程
	parallel scavenge：新生代，多线程，关注点为将垃圾回收时间控制在可控范围内
	serial Old:老年代，单线程
	Parallel Old：老年代，多线程
	CMS：使用标记-清除算法，与用户线程同时运行，进行并发标记，并发清除，缩短Stop-The-world时间
	G1：并发（利用多线程与多cpu，缩短停顿），分代收集，空间整合（GC后内存连续），可预测的停顿（指定GC时间在N ms内）
	
G1:
	-XX:MaxGCPauseMillis=50  //gc在50ms内完成
	-XX:G1HeapRegionSize=1~32 //G1的每个Region大小为1-32M
	-XX:+PrintGCDetails
	
准备开始GC
	1.jvm有多条运行的线程
	2.GC时线程必需停止
	
	停止运行的线程
		jvm设置了一个safepoint，并让线程主动式（通过轮询标志位状态）中断，使线程运行到safepoint时中断下来
	进行GC
		线程都中断后，进行垃圾回收
		
