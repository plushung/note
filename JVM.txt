运行时数据区域	
	方法区（永久代）：存放class的元数据，和常量池，
		jdk8后：	
			被移除，方法区用本地内存的元数据空间（metaspace）取代。
			类的元数据放入 native memory, 
			常量池和类的静态变量放入java堆中
			通过-XX:MaxMetaspaceSize=128m指定元数据空间大小，不设置JVM将会根据一定的策略自动增加本地元内存空间。
	运行时常量池（与class文件中的常量池区分开）
		class文件中的常量池在类加载后被方进方法区的运行时常量池
		class文件的常量池的内容在编译时就会完全确定下来，包括各种字面量和符号引用
		运行时常量池可以动态地添加新常量，如String的intern()方法
		
	堆区：
		存放数据对象实例
		
		新生代
			Eden空间，From Survivor空间，To Survior空间
		老年代
			
	虚拟机栈区：
		存放线程工作状态,存放每个要执行的方法，存放变量(引用，字面量)，调用函数时线程状态保存在棧区
		每条线程都会分配到独立的内存，其中有一个栈区，栈中存放的是该线程要执行的方法的栈帧
		每个栈帧保存方法执行所需的局部变量表，操作数栈，动态连接，方法出口(returnAddress)。
		栈顶栈帧与线程正在执行的方法关联，称当前栈帧。
		
		运行时栈帧结构
			局部变量表：	存放方法参数与方法局部变量         | slot0(方法调用者的引用) | slot1 | slot2 |  
				是一组变量值存储空间，存放方法参数与方法局部变量。以变量槽为最小单位（Slot）
				类型除基本类型外还有reference和returnAddress类型。
				reference表示对一个对象的引用。
				第0位的slot为调用此方法的对象的引用
				slot在不同的作用域内是可重用的，若一个变量超出其作用域（大括号范围），并且没有新的变量复用该slot，该过期的局部变量会一直都在，直到方法结束。
				如果超出其作用域的局部变量的slot没被复用，该局部变量引用的对象不会被GC清理。  
				//类似栈操作？退栈改变栈顶指针，但原位置内容不变。
					byte[] waste = new byte[6 * 1024 * 1024]; 
					int new_var = 0; 
					//此时GC waste引用的对象不会被回收
					-------------------------------------------------------------------------------------
					{
						byte[] waste = new byte[6 * 1024 * 1024]; 
					}
					int new_var = 0; 
					//此时GC waste引用的对象会被回收，由于new_var复用了超作用域的waste的slot，waste引用的对象不再有引用
				局部变量一定要赋值，因为系统不会给局部变量赋初值
			操作数栈
				后入先出栈，保存即将使用操作数，在算术运算时或调用其他方法时使用操作数栈
			动态连接
				每个栈帧持有该栈帧在运行时常量池所属方法的引用，为了支持动态连接。
				字节码调用方法时以方法的符号引用作参数
				1.（静态解析）方法的符号引用在类加载时或首次使用时转换为直接引用	//类方法在类加载时就将符号引用替换为直接引用
				2.（动态连接）方法的符号引用在每次调用时方法时才转化为直接引用	//调用接口的方法时，在运行时才能确定实现方法的直接引用
			方法返回地址
				正常情况，栈帧保存该方法被调用时的PC计数器的值作为方法的返回地址，方法返回后将pc计数器的值置为该方法出口的值
				异常情况，返回地址由异常处理器确定。

	本地方法栈：
		本地方法执行时的内存区域
	HotSpot将两个栈区合并为一个栈
	程序计数器：
		1指示线程当前执行到的字节码的行号。
		2若线程当前执行的方法是Native方法则为0
		3该区域是jvm中唯一没有OutOfMemoryError的区域
	
变量存放例子：			
	class demo｛
	static int a=1；	//static变量a——>方法区（jvm8后放在java堆），整型字面量 1——>存放在常量池
	static final int b=2； 
	int c=3；		//实例变量c随demo的实例对象保存在堆中，字面值3保存在常量池
	String ss1 = new String("china");   //ss1保存在java堆中，new在堆中创建一个String对象，china字符串常量在常量池中存放
	public void method（）｛
			int d=4；	//d为基本局部变量连同字面量4，保存在栈帧的局部变量表中，4在栈中只存在一份；
			String ss2=new String("china1") 	//ss2为局部变量，保存在栈的局部变量表中，new出来的String对象保存在堆，China1字符串常量保存在运行时常量池
		｝
	｝
	静态field在类加载的初始化阶段用<clinit>被赋初值初始化
	实例field在实例调用构造函数时用<init>方法初始化
	https://blog.csdn.net/qingtiantianqing/article/details/51172845

垃圾回收机制
	java的内存管理使用自适应的垃圾回收技术:"标记-清除"+"停止-复制"
		自适应：      活对象多时，标记-清除。活对象少时，停止-复制。
			当无用对象的内存碎片较少时，自适应地使用"标记-清除"法来进行垃圾回收 
			当无用对象的内存碎片较多时，自适应地使用"停止-复制"法来进行垃圾回收
		
	查找'活'对象（可达性分析）
		从GC根节点开始遍历对象
		通过遍历堆栈区和静态存储区的引用，找出这些引用所指向的存活的对象。二次标记。
	
	实施清理算法
		停止-复制:（多无用内存时 MinorGC）（活对象少时，复制）
			在清除无用对象，释放内存前先停止程序运行，再执行清除工作
			缺点：
				浪费了一半的内存来做复制操作
			过程
				1.查找'活'对象
				2.将活的对象复制到内存中的新的堆上并合理排序		//复制过程中对对象进行了编排，所以清理后空闲的内存地址空间是连续的
				3.更新存活对象的引用
			
			适用
				因为是要停止程序和用复制的方式，频繁停止-复制会造成性能损失
				所以适用于活对象比较少的情况
			
		标记-清除:（少无用内存时）
			不进行对象复制，只是对存活的对象进行标记，然后把没被标记到的对象的内存释放
			
			过程
				1.查找'活'对象，并标记
				2.清除没被标记对象的内存	//清理过程知识释放无用对象，所以清理后空闲的内存地址空间是不连续的
			
			适用
				因为是通过程序运行时标记对象的方式，不用暂停程序，在只有少量碎片时既可以保证程序性能，又能释放内存空间
				所以适用于无用对象比较少的情况
		
		标记-整理：	
			不直接清理可回收对象，将存活对象向一端移动，覆盖可清理对象，清理存活对象端边界外的内存，更新引用
			
		分代收集法（G1）：
			将java堆分为一系列年轻代和老年代区，不同区用不同GC算法（自适应）
			年轻代区域存活对象较少，使用Copy to Survivor（复制算法）
				新生代包括Eden和Survivor区
				将Eden和Servicor中的存活对象，复制到新的Survivor区，若新的Survivor不够大则复制到老年代区，完成GC
				Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）
			老年代区域存活对象较多，使用标记-整理进行GC
				老年代：主要存放应用程序中生命周期长的内存对象

垃圾收集器
	新生代都用复制算法清理
	老年带使用标记-整理算法清理
	新生代
		*serial：新生代，单线程
		parNew：新生代，多线程
		parallel scavenge：新生代，多线程，关注点为将垃圾回收时间控制在可控范围内
		G1	新生代，标记-复制
	老年代
		*serial Old:老年代，单线程，标清
		Parallel Old：老年代，多线程，标清
		CMS：	老年代，多线程，标清
			使用 标记-清除 算法，与用户线程同时运行，进行并发标记，并发清除，缩短Stop-The-world时间，几乎不会使用户线程停止
			对CPU敏感，需要使用很多CPU资源
		G1： 老年代，多线程，标记-整理
			并发（利用多线程与多cpu，缩短停顿），分代收集，空间整合（GC后内存连续），可预测的停顿（指定GC时间在N ms内）

GCRoot	
	全局引用对象，执行上下文（GC时，线程执行到的方法上下文）引用对象
	
	虚拟机栈中（栈帧的局部变量表）引用的对象（实例方法体中引用的对象）
	类的成员变量引用的对象
	final 常量引用的属性
	Native 本地方法引用的对象	


	1.从CGRoot对象开始遍历对象的引用链。
	2.第一次标记不在引用链上的对象
	3.若被标记对象的finalize()方法已被调用过或没被覆盖则直接进入“即将回收”集合，准备被清理
	4.若被标记对象的finalize()方法未被调用过，则将对象放入一个F-Queue队列。
		虚拟机使用Finalizer线程调用对象的finalize()方法。稍后GC对F-Queue中的对象二次标记，
		若在finalize()方法中对象再次与引用链相连，则不会被GC
	5.最终被标记的对象放在"即将回收"集合中，等待下一步回收工作
	
G1:
	G1将内存划分为多个固定大小的region存放对象（YGC，OGC）		
		//物理上不连续，G1的新生代与老年代的物理空间不分开，其他GC器将新生代与老年代的物理空间分开（CMS）
	每个region有一个membered Set保存到其他Region或到其他收集器的对象的引用	
		//不用全堆扫描
	
	步骤
		初始标记：stop the world，只标记GCroot的直接关联对象			  （GCRoot的对象）
		并发标记：同用户线程一起运行，标记所有GCRoot可达的对象（可达性分析）（被GCRoot引用的对象）
		最终标记：stop the world，修正并发标记时的，用户运行导致的标记变动的那部分标记记录
		筛选回收：对Region估计回收价值，排序，执行回收计划

Full GC
	stop the world，GC时暂停用户线程
	
	准备开始GC
		1.jvm有多条运行的线程
		2.GC时线程必需停止
		
		停止运行的线程
			jvm设置了一个safepoint，并让线程主动式（通过轮询标志位状态）中断，使线程运行到safepoint时中断下来
		进行GC
			线程都中断后，进行垃圾回收
		
JVM参数	
	最大垃圾收集暂停时间：-XX:MaxGCPauseMillis=50  //gc在50ms内完成
	设置每个G1堆区的大小：-XX:G1HeapRegionSize=1~32 //G1的每个Region大小为1-32M
	打印垃圾收集信息：-XX:+PrintGCDetails	
	直接晋升到老年代的对象大小：-XX:+PretenuerSizeThreshold=15
	在新生代经历过n次MinorGC后的对象存放到老年代：-XX:+MaxTenuringThreshold=5
	使用某垃圾收集器：
		-XX:+UseSerialGC  //Serial+serialOld
		-XX:+UseParNewCG //ParNew+SerialOld
		-XX:+UseConcMarkSweepGC //并发标记清除GC，ParNew+CMS
		-XX:+UseG1GC    //G1
	-XX:+DisableExplicitGC   //禁用System.gc（）
	-Xms20M 堆初始大小20m
	-Xmx20M 堆最大20M
	-Xmn10m new新生代占10M
	-XX:SurvivorRatio new新生代中Eden与一个Survivor之比
	-XX:NewRatio	新生代与老年代比值1：n
	-Xloggc:gcfile.log  //将GC信息输出到文件
	-Xint  		 //将虚拟机运行与解析模式，仅使用解析器解析执行
	-Xcomp		 //强制vm使用编译模式，仅使用编译器编译后执行
	-client		 //指定虚拟机使用Client模式编译器
	-server		 //使用server模式
	
	打印信息
		-verbose:class 	 //打印类加载信息
		-verbose:gc 	 //打印GC信息
	
新生代到老年代 		分配担保，大对象，老年对象（age=15），动态对象年龄
	1.GC时，Eden执行minor GC，Eden的对象被复制到Survivor，Survivor放不下则被复制到老年代，（分配担保机制），若老年代也不够大，则对老年代进行FullGC
	2.新生代对象的每次Minor GC，会使对象age+1，当对象的Age达到-XX:MaxTenuringThreshold时（默认15），则被复制到老年代区
	3.新建对象若大于-XX:+PretenuerSizeThreshold,则直接存放到老年代， 大对象如：长字符串，大数组
	4.survivor中age相同的对象较多时，比age大的对象被晋升为老年代

类文件结构			//使用javap -verbose className ，查看.class文件
	类文件使用类似c的结构体的伪结构体存储类信息
	只有两种数据类型----无符号数+表
		无符号数
			描述数字，索引引用，utf8字符串，数量值
			类型有u1，u2，u4，u8
		表
			由若干个无符号数和表构成的，具有层次关系的复合结构数据
	
	类文件结构排布
		u4 magic：魔数，用于验证该class可否被jvm接受
		u2、u2 Minor_version、major_version：主次版本号，可被版本号大于等于该版本号的jvm运行
		u2 Constant_pool_count：常量池计数，从1开始计数，0表示为不引用常量池项目
		cp_info表 constant_pool：常量池，存储类相关的字面量和符号引用
			字面量：java中的常量和final型常量值
				字面量实际是一个表，表中的byte元素的值是实际存储的字符串
			符号引用：
				符号引用实际是表，构成该表的元素的值是一个指针/索引，指向其他表（utf8）
				1.类或接口的全限定名
				2.方法的名称与描述符
				3.字段的名称与描述符
			常量池项目结构（每种项目都是表）
				1.tag，第一个字节为项目类型标志位
				2.表的有用内容
				
				常用类型：
					class中的方法和字段都要引用CONSTANT_Utf8_info（又是一个index）来描述名字，因此方法名或字段名的长度不能超过length个字节
					CONSTANT_Utf8_info:
						utf8字符串，里面除了tag外，有一个u2的length字段（65535），表示该字符串长度，bytes字段是一串字符
						#5=utf8 	fieldname1		//字符串
						#6=utf8 	I			//字符串，表示类型int
						#7=utf8 	myclss/test/Check	//字符串，类的全限定名
					CONSTANT_Class_info:
						类或接口的符号引用，index位是指向该类或接口全限定名字的字符串（CONSTANT_Utf8——info类型）的一个索引，表示类的名字
						index的值为常量表中的某个位置，表示类名
						#1=class	#7			//类的符号引用，指向类名字符串
					CONSTANT_Fieldref_info:
						字段的符号引用，
							第一个index是指向该字段所属的类---->CONSTANT_Class_info的索引(属于那个类)
							第二个index是指向该字段的名称与描述符--->CONSTANT_NameAndType_info的索引(名称及类型) //fielda：I
						值：
						#8=Field	#1.#9		//类的符号引用.字段的名称与类型
					CONSTANT_Methodref_info、CONSTANT_interfase-Methodref_info:
						类中方法的符号引用,与字段的符号引用类似
						第一个index是指向该方法所属的类的------->CONSTANT_Class_info的索引(属于那个类)
						第二个index该方法名称与类型------->CONSTANT_NameAndType_info // methodName:(I)V  方法名：methodName  入参：I（int） 返回值：V(void)
					CONSTANT_NameAndType_info
						字段或方法的部分符号引用
						第一个index，名称----->CONSTANT_utf8_info
						第二个index，描述符（类型）----->CONSTANT_utf8_info  
						值：
						#9=NameAndType	#5:#6   //名称的字符串的引用：表述类型的字符串的引用
					CONSTANT_String_info:
						String类型的字符串字面量，index位是指向字符串字面量的索引，表示字符串常量值
					CONSTANT_Integer_info：	
						整型字面量，有一个u4的bytes字段，高位在前，存储最大值为2^32的数，此规定使得java中的int类型的值固定为32位
					CONSTANT_Float_info：u4 bytes
					CONSTANT_Long_info：u8 bytes
					CONSTANT_Double_info：u8 bytes
					
					其中的所有索引都是指向常量表中的某个位置			
		u2 access_flags：类的访问标志，标识类或接口的层次访问信息（Class or Interfase，public?,abstract?,final class?）
		//以下Class元素，都会引用常量池的符号引用或字符串常量
		u2 this_class/super_class/interfaces:------->CONSTANT_Class_info
			是指向类描述符常量（CONSTANT_Class_info（符号引用））的索引指针，//解析阶段，会将符号引用替换为直接地址指针引用
			描述类的继承关系，interfaces（接口索引集合）还有个interfaces_count记录类实现的接口数
		field_info表 fields:
			字段表集合，描述每个字段的信息，
			name_index字段的简单名（非全限定名）的索引------>CONSTANT_Utf8_info，
			describe_index字段类型的索引------->CONSTANT_NameAndType_info // name:type
			,都是对常量池的引用
		method_info methods:
			name_index方法的简单名（非全限定名）的索引------>CONSTANT_Utf8_info，
			describe_index方法参数列表和返回值描述------->引用CONSTANT_NameAndType_info // name:type
			Attribute_count 属性表的个数
			attribute_info 方法表的属性
				Code属性表
					存放的是字节码中方法的Code里的字节码指令，
					Code属性表的attribute_name_index为该属性表名在常量池的索引，常量池中有一个“Code”的utf8常量
					Code表的属性
						LineNumberTable属性
							Code里的属性，java源码中的行号与字节码中的行号的映射 ex:line 15:0,表示源码的15行对应字节码的0行指令
						LocalVariableTable属性
							Code里的属性，方法的局部变量描述，slot信息
		attribute_info attributes:
		
类加载
	加载：	如何取得类的二进制字节流
		1通过类的全限定名取得定义此类的二进制字节流
		2.将类的二进制字节流转化为方法区的运行时数据结构，存储在方法区中/metaspace
		3.在内存（堆）中生成该类的Class对象！，用于访问该类在方法区的各种数据
			class对象，只用来作为访问方法区中类的二进制数据的外部接口
		注意：
			类的二进制字节流不一定在.class中取得
			类的二进制字节流可以从zip包中取得，如jar，war包
			类的二进制字节流可从网络中取得
			类的二进制字节流可运行时计算得到，如JDK动态代理生成的类，为某接口生成代理类
			类的二进制字节流可有其他文件生成，如JSP生成servlet类
			。。
			
		类加载时先调用父类加载器，若父类加载器不能加载才由自己加载
			
		定义自定义类加载器，来控制类的二进制字节流获取方式
	连接	
		验证：
			文件格式验证：验证魔数、主次版本号，常量池常量的tag标志，指向常量的索引，
			元数据验证：对元数据信息进行语义验证（如是否覆盖父类final字段），是否符合java规范
			字节码验证：
			符号引用验证：发生在解析阶段，将符号引用替换为直接引用时
		准备：	为静态变量分配内存，系统赋初值0
			为类变量（static变量）分配内存（方法区）并设置初始值0值，仅仅是给static变量分配内存，不给实例变量分配内存
				在初始化阶段才为类变量赋值123
			若为final static变量，则在此阶段为其分配内存并在常量池中生成int常量123并设置初始值为123常量值，不用到初始化阶段才赋值
			
		解析： 将符号引用解析成直接引用 解析类或接口的符号引用-->根据类解析字段的符号引用-->根据类解析方法的符号引用
			解析前class中的字节码指令的参数全是符号引用，解析后将所有符号引用替换为直接引用，解析的时机不确定
			类或接口解释
				this_class=#10(CONSTANT_CLASS_info)
				--->this_class=class对象的地址
				将符号引用：CONSTANT_CLASS_info解释成对应class对象的直接地址
			字段解析（CONSTANT_Fieldref_info）
				将未解析过的字段的符号引用替换为直接引用
				field=#8(CONSTANT_Fieldref_info)
					{
					class_index=#10(CONSTANT_CLASS_info)
					describe_index=#5:#6
					}
				---->field=class.field1的地址
				先解析第一个index即字段所属类的符号引用（CONSTANT_class_info），解析成class对象C
				从class对象C中查找是否有与该字段的简单名称与描述符都相同的字段，有则返回class对象该字段的直接引用
					否则从C的接口和父类的class对象中找该字段的直接引用，有则返回，无则报错
				最后对字段的访问权限验证，无访问权则报错
			类的方法解析（CONSTANT_Methodref_info）
				先解析第一个index即字段所属类的符号引用（CONSTANT_class_info），解析成class对象C
				从C中找名称与描述符都符合的方法的直接引用，即C.method的地址，无则从父类和接口中找
			
			class对象是在加载阶段生成的
	初始化(类初始化):		程序员赋初值，字节码中用<clinit>方法初始化类变量
		对类变量初始化！！！是初始化类变量（static），只会被初始化一次（每个类只有一个class对象）
		何时初始化：使用类前初始化
			1.new一个实例时,调用类静态方法时，设置或读取静态字段时
			2.对类进行反射调用时
			3.子类被初始化前，先对父类初始化
			4.执行某类的main方法时，先初始化该类
			5.使用动态代理时，先对被代理的类初始化
		
		若类中编写了static代码块，则该static块会与static变量合并产生类构造函数<clinit>()，对类变量按照程序员的意图进行初始化赋值。
		类构造函数<clinit>()与实例构造函数<init>()是不同的,前者初始化一个类对象的类变量，后者初始化类的实例对象的变量。

对象的内存模型
	https://img-blog.csdn.net/20151217151455512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center
	对象占内存大小必需是计算机处理器位数（32bit 64bit）的倍数，HotSpot虚拟机是64bit位的
	对象实际是C/C++中的一个结构体像是	
		typedef struct object{
			Header *MarkWord=malloc(32);	//MarkWord内存：|25bit：Hashcode|4bit：GCage|1bit：0|2bit：标志位|	
			Data *InstantDate=malloc(x)
			Padding *padding=malloc(32-x%32)
		}Object；
	对象头	32bit或64bit
		存储对象本身信息的区域，分为对象自身的运行时数据和对象类型在方法区的指针两部分
		1对象自身运行时数据区域（MarkWord）	//参考上面的object结构体的MarkWord字段
			HashCode，GCage，锁状态标志，线程持有锁，偏向ID，偏向时间戳
			根据对象的锁标志位，决定该MarkWord区域存储的是什么数据
			标志位为01、未锁定
				HashCode，GCage，标志位，固定位0
			标志位为00、轻量级锁定
				指向锁记录的指针，指针所指向的栈中地址存放markword的实际信息（hashcode，age，标志位，固定位0）
			标志位为10、重量级锁定
				指向重量级锁的指针
			标志位为11、GC标记
				空
			标志位为01、可偏向
				偏向线程ID，偏向时间戳，age
		2.对象的类型指针
			指向对象的类元数据的指针(方法区)
	实例数据	所占空间不定
		存储有实际价值的数据
	填充		占用空间使整个对象占内存大小是32bit或64bit的倍数
		内存占位符
		
	
		
对象创建
	1.检测类加载		
		执行new指令时，看该指令的参数是否在常量池中的一个类的符号引用
		然后若类未加载则先加载该类
	2.分配空间		类比：类加载准备阶段的分配空间
		若内存连续规整则采用指针碰撞为对象分配空间地址	（Serial，ParNew的基于复制算法）
		若内存不连续则采用空闲列表的方式分配空间地址	（若老年代采用CMS，则基于标记-清除算法，）
		一般采用CAS+失败重试的方式为对象分配多线程争用的内存地址
	3.系统初始化	类比：类加载准备阶段的赋初值
		jvm为将对象分配到的内存初始化为0值
	4.设置对象头	类比：类加载的解析阶段
		
	5.用户初始化	类比：类加载的初始化阶段调用<clinit>方法
	用invokespecial指令执行对象的<init>方法，按程序员意图初始化对象，调用执行子类的<init>是，首先执行父类的<init>方法
	
类加载器	
	作用：	
		将通过类的全限定名从某处获取的类的二进制字节流。如何获取有具体的类加载器决定。实现类的加载动作
	类的唯一性
		由一个类本身及加载该类的类加载器共同决定该类在jvm中的唯一性。
		即对于同一个类，不同类加载器加载得出的类在jvm中是不同的，是独立的两个类。
	
	类加载器
		启动类加载器 Bootstrap ClassLoader
			C++实现，顶层类加载器，加载JAVA_HOME\lib下的类库，不可直接使用，-Xbootclassloader=。。指定启动类加载器加载的库路径
		扩展类加载器 Extension ClassLoader
			java实现，加载JAVA_HOME\lib\ext下的类库，可直接使用。
		应用程序类加载器 Application ClassLoader （系统类加载器）
			java实现，加载用户应用ClassPath下的类，可直接使用。
		自定义类加载器
			java实现，自定义加载类，由用户实现加载过程
	双亲委派模型
		类加载器收到某类的加载请求时，先交给父类加载器加载，若父类加载器加载不了请求的类时，子类加载器才尝试自己加载。
		！类的加载不一定按照双亲委派模型进行。
	破坏类双亲委派模型
		1.java基础类调用用户模块时
			父类加载器加载的类依赖只有子类加载器才可加载的类时，必需破坏双亲委派模型。否则，不能正常加载。
			如JNDI是基础类有启动类加载器加载，JNDI的具体实现类由用户实现，JNDI的实现类不由启动类加载器加载。
		 	但是，JNDI的加载又要加载其实现类，就只能破坏双亲委派模型，让JNDI实现类交给线程上下文类加载器（默认为应用类加载器）加载
		2.在不停机的情况下实现java系统模块的热部署，热替代
			若要使应用系统的各部分模块能够在系统运行时动态部署，像计算机系统的外设热拔插那样。就必需破坏双亲委派模型，来加载类。

方法调用
	方法的解析（类加载时的解析）
		静态解析（类加载时在解析阶段符号引用就替换为直接引用）
			“编译期可知，运行期不变”在类加载时就将字节码指令引用的这类方法的符号引用替换为直接引用，
			包括 类方法，私有方法，父类方法和实例构造器
			，在编译时完全确定，代码编写时就可以确定这类方法在运行时是一定不会变的
		动态连接（方法在每次运行时才将方法的符号引用替换为直接引用）
			每次执行字节码指令时才将参数的符号引用替换过为直接引用
			栈帧中的动态连接引用的方法符号引用在每次运行时才被替换成直接引用
		
	方法的版本选择(多态性)
		分派-----java多态性的实现原理
			静态分派：		//典型用法：方法重载，根据参数的静态类型和数量，在编译期间完成
				调用方法在编译期根据方法参数的静态类型来定位方法的执行版本。	//方法的返回值不能参与方法重载，因方法的签名只有方法名+参数表
				由编译器执行对方法的分派
				多个同名方法，参数不同，根据参数的静态类型在编译期间将要调用的方法的符号引用写到字节码的参数中。
			动态分派：		//典型用法：方法重写，根据调用方法者（接收者）的实际类型，在运行期间完成
				方法在运行期间根据调用该方法的对象的实际类型，确定方法执行的版本，将方法的符号引用替换为对应的直接引用。
				由虚拟机执行方法的分派
				
				动态分派例子：	
					invokevirtual字节码指令表示执行普通非静态非私有方法，
					在运行期执行该指令时才根据方法所属类型（class_index），将方法的的符号引用解析为直接引用
	
	方法的解析与分派
		解析与分派是从不同层面上确定方法的过程
		解析		//类方法，私有方法，父类方法和实例构造器等方法的解析	 关注点在于何时将方法的符号引用变为直接引用
			何时将符号引用解析成直接引用
			一定是静态过程，在编译期间类加载时期的解析阶段
		分派		//典型用法：方法重载，方法重写    				 关注点在与用哪个方法
			确定要调用多个同名方法中哪一个
			可以分静态过程和动态过程
			静态：编译时多态		焦点在于给方法传递的参数的静态类型
				编译期间确定调用哪个方法，编译器来决定
				编译时根据方法参数的静态类型确定方法的符号引用	
			动态：运行时多态		焦点在于方法调用者的实际类型
				运行时才确定调用哪个方法，jvm来决定
				运行时根据方法符号引用的class_index确定所属类型，并将符号引用替换为该类型该方法的直接引用
				
	解释执行时的方法调用
		1将调用方法的对象引用从局部变量表load到操作数栈顶
		2再将方法的入参load到操作数栈顶
		3遇到invokevritual指令就将操作数栈的元素出栈执行对象的方法 	//invokevritual指令进行多态查找
		4方法返回对象入操作数栈
		5. 若要保存返回对象，则用astore指令将操作数栈的对象弹出并放入局部变量表
		  若不保存返回的对象，则用pop将操作数栈的对象弹出
		  
	invokevritual指令多态查找 	//动态分派的过程
		1.确定方法接受者的实际类型C
		2.查找C中方法表中是否有方法的简单名、描述符，与符号引用的简单名，描述符相匹配的方法
			无则在C的父类中查找
		3.有则返回方法的直接引用
	在Class文件中的常量持中存有大量的符号引用。字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。

	

自动装箱
	直接将字面值赋值给包装类，在初始化时会通过包装类的静态方法ValueOf(),将int转化为包装类
	
字节码的执行
	早期java的.class字节码的执行一定是通过解释器去解析执行的
	后来虚拟机包含了即时编译器JIT，字节码的执行是解析执行还是编译执行由虚拟机才能准确判断
	解释执行方法中的字节码
		通过基于栈的解析器解析执行字节码
		1.程序计数器记录当前执行的字节码行号
		2.*push指令将常量值压入操作数栈
		 .*store_i指令将操作数栈顶的整数值出栈并放到局部变量表的第i个slot，
		 .*load_i指令将局部变量表的第i个slot的整型值复制到操作数栈的栈顶
		 .add|mul|div|sub 将操作数栈栈顶的头两个元素出栈运算，运算结果重新压入操作数栈
		 .*return指令将操作数栈的栈顶元素返回给方法调用者，并结束方法
		 
	即时编译执行字节码
		通过JIT编译器，在运行时对字节码编译成机器码来执行。
		何时使用即时编译
			被多次调用的方法
			被多次执行的循环体
			//若方法的调用计数器超过阈值，就会对方法的字节码进行编译，编译成本地机器代码。之后在调用该方法就会直接调用方法的本地机器码。
		

jvm编译运行
	早期:前端编译期
		将.java编译成.class 	//前端编译器：javac，eclipse的JDT
	晚期:运行期
		一般情况下对编译期产生的.class进行加载并用解析器解析运行
		若存在频繁运行的代码块或方法，则用JIT编译成本地机器码运行以提高这些代码的运行效率
		将.class编译成机器码	//JIT编译器:HotSpot的Client,Server编译器
	
	字节码执行方式
		第一种：即时编译方式，编译器先将字节编译成机器码，然后再执行机器码。		//节约内存
		第二种：解释执行方式，解释器通过每次解释并执行一小段代码来完成java字节码程序的所有操作	//提高代码执行效率
	
	即时编译时优化
		这里的“编译“是指运行时即时编译运行，用JIT编译字节码运行。以提高代码运行效率
		为什么效率高?
			1.解析器解析运行字节码消耗额外时间
			2.JVM的设计把代码的优化措施几乎全集中在JIT编译器中。
		
		优化技术
			公共子表达式消除
			数组范围检测消除
			方法内联
			逃逸分析
	
	HotSpot虚拟机使用解析器+JIT并存的架构

java内存模型与线程
	主内存
		保存所有变量的地方，所有线程共享，使用时将变量复制到线程的工作内存
	线程的工作内存
		保存线程执行时所用变量的主内存的副本的内存，每条线程有一个工作内存。
		线程运行只使用工作内存中的变量副本，在需要时将工作内存的变量副本与主存的变量同步
	
	内存间的交互
		定义主内存复制到工作内存及工作内存同步到主内存的操作
		lock、unlock
		read---->load
		use
		assign
		store--->write
	
	普通变量	//工作内存与主内存同步延迟
		线程读写普通变量，
		读变量值前若果工作内存存在变量副本，就先使用工作内存中的副本，
		写入变量值后，工作内存中的变量不会立即同步到主内存。
		导致线程对变量的修改，对其他线程不是立即可见
	volatile变量	//工作内存与主内存同步实时
		线程对该变量的读写操作前后，读前立即从主内存将值复制到工作内存，写后立即将值同步到主内存，保证该变量的可见性
		
	java内存模型保证并发过程的原子性，可见性和有序性
		原子性：
			内存模型保证read---->load，use，assign，store--->write操作是原子性的
			若需要运算操作等的更大范围的原子性，需用lock/unlock来保证原子性，通过monitorenter|exit指令间接使用lock/unlock，synchronized使用了这两个指令
			通过synchronize保证大范围的原子性，或atomic原子类保证变量运算的原子性
		可见性：
			内存模型提供volatile变量，保证变量在多线程环境中的可见性，通过实时同步保证
			synchronized在unlock前立即同步工作线程的变量到主内存中，保证可见性
			final变量一经初始化就不能改变，也保证了可见性。
		有序性：
			内存模型提供volatile变量，保证程序指令执行的有序性，因volatile有禁止指令重排的语义
			synchronized关键字规则：一个变量同一时间只能被一条线程lock操作。因此也保证了有序性
		
线程安全的实现方法
	1.互斥同步
		synchronized控制的代码
			通过字节码的monitorenter和monitorexit指令，锁定一个对象。同一线程可重入，计数加+。
		ReentrentLock控制的代码(功能更多，性能可能好点)  原理是用CAS对状态进行更新来获取锁
			同样可重入   
			与synchronized相比的优势：
				等待可中断，可实现公平锁（按线程进入等待队列的事件顺序等待取得锁），锁可绑定多个条件（Condition）。
			JDK1.6后
	2.非阻塞同步
		通过硬件层面保证语义上要多次操作的行为只通过一条处理器指令就能一步完成。保证了行为的原子性。
		此类处理器指令有
			测试并设置，获取并增加，交换（swap），比较并交换（CAS），加载链接/条件存储（LL/SC）
		java中的CAS实现
			java中由sun.misc.Unsafe类提供硬件层面的CAS，不能直接使用Unsafe类，只能通过JUC包的atomic原子类来使用。
			！可能出现ABA问题
	3.不采用同步
		编写可重入代码
			即无状态方法
			1.不依赖堆上的数据与公共的系统资源
			2.用到的状态量由参数传入
			3.不调用非可重入方法
			
		使用线程本地变量
			ThreadLocal<T>	

锁优化	//jdk1.6的优化
	自旋锁与自适应自旋锁
		互斥锁问题
			使用普通锁时，线程因需要等待获得锁而使cpu频繁挂起和恢复线程，带来了额外的开销。
		自旋锁		//JDK1.6后默认用自旋锁
			线程需要等待获得锁时，不会挂起而是进行忙循环（自旋）。
			自旋锁若忙循环了默认的10次后还没获得锁，则按传统的方式挂起线程。
			-XX:PreBlockSpin参数设置自选次数（默认10）
		自适应自旋锁	
			若线程在自旋等待时刚刚获得过锁，则在下一次自旋等待时允许自旋更多次
			
	锁消除
		在JIT编译运行时消除不必要的锁
		通过逃逸分析技术，判断堆上的数据会不会逃逸出去被其他线程访问到，
		若数据不被其他线程访问到则认为该数据是线程私有的，数据同步就不必要进行，进而消除锁。
		ex：方法的局部变量StringBuffer，其实现中用到的锁在JIT时会被消除
	
	锁粗化
		若遇到对同一对象的连续加锁/解锁操作，则会使这连续多次的加锁/解锁操作合并为一次加锁/解锁操作
		ex：连续调用加了同步锁的方法，如StringBuffer的append()方法
	
	轻量级锁		//在竞争不太激烈的场景下使用，基础为CAS
		本意
			在没有多线程竞争的前提下，减小重量级锁使用互斥量产生的性能损耗。
			即无竞争时，用cas使线程取得轻量级锁，在多线程竞争锁时，才用膨胀为重量级锁
	
		通过CAS操作对对象的对象头做修改，使MarkWord指向线程的栈帧中的锁记录空间，避免使用互斥量的开销。	
		在存在锁竞争时，轻量级锁膨胀为重量级锁，并将MarkWord的标志位设置为10.	
		在竞争激烈的场景下不仅有重量级锁的开销，还有CAS的开销，此时轻量级锁比重量级锁更慢
	
	偏向锁
		线程获得过偏向锁后，以后若无其他线程获得过锁，则线程每次运行到被该所控制的同步块时都不再做同步操作			
	
逻辑集群应用
	由于64位jdk存在一些问题，在大型应用中性能可能不能发挥到最好，所以使用32位jdk的应用集群，以完全发挥出硬件性能
	
	集群应用部署
		集群的每个节点为一个服务器
		1.使用前端负载均衡器，分发请求到服务器群的某个端点，作为用户访问代理
			对于服务器集群间的session同步问题，采取同一session的请求分发到固定的一个节点上（亲合性）
		2.资源池的使用（如：数据库连接池）
			采用每个节点一个资源池的方法
		3.采用缓存（如redis）
			建议：采用集中式缓存，即所有节点共用一个缓存节点
			不建议：本地缓存（每个节点拥有一个缓存）在集群时会造成极大的内存浪费
			
	垃圾收集器选择
		高CPU敏感度应用
			即使用大量CPU资源的应用，线程非常多的应用。
			此时使用CMS会造成应用性能突然下降，因CMS多线程，占用计算过资源
		低CPU敏感度应用
			即很少使用CPU资源，比较多访问IO等磁盘访问的应用
			此时使用CMS可大大提高应用性能，因CMS是与用户线程并发运行的，几乎不会造成应用的停顿（只在重新标记时短暂停顿）