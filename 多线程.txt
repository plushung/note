多线程：指的是这个程序（一个进程）运行时产生了不止一个线程.

并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。

线程安全：一段代码在并发的情况下执行，经过多线程使用，线程的调度顺序不影响结果。线程不安全就意味着线程的调度顺序会影响最终结果。

同步：通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。在代码方法上加入@synchronized关键字。
方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中


其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态,等待系统调度运行

等待阻塞：调用wait()，使该线程处于等待池,直到notify()/notifyAll()，线程被唤醒被放到锁定池，释放同步锁使线程回到可运行状态

同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
	进入可运行状态后等待cpu调度进入运行状态Running
	yield方法可以让一个running状态的线程转入runnable。


Thread.interrupted()检查当前线程是否发生中断，返回boolean
中断是一个状态！interrupt()方法只是将这个状态置为true而已。

!!!!①wait() 与 notify/notifyAll 方法必须在同步代码块中使用
线程等待：Object类中的wait()方法，wait()也会让当前线程释放它所持有的锁
	导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法
	因为wait需释放锁，所以必须在synchronized中使用（没有锁定则么可以释放？没有锁时使用会抛出	IllegalMonitorStateException（正在等待的对象没有锁）

线程唤醒：Object类中的notify()方法

线程让步：public static Thread.yield()
	转让cpu控制权，让别的就绪状态线程运行

线程睡眠：public static Thread.sleep() 
	暂停一段时间
　　　　
线程加入：public join()
	在一个线程中调用其他线程.join(),将等其他线程执行完后才继续本线程。

-------------------------------------------------------------------------------------------------------------------
使用前要对obj加同步锁
!!!!①wait() 与 notify/notifyAll 方法必须在同步代码块中使用，必需是由被锁定的对象obj调用
	当某线程获得该obj锁，并调用该锁的wait（），该线程会被置于obj锁的等待队列，同时释放obj锁
	直到obj的notify（）或notifyAll（）被调用，该线程重新获得obj锁，该线程才能继续运行

synchronized修饰:
	类，方法，同步块
	构造方法不能使用synchronized关键字

每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 

synchronized(obj){} //obj的锁控制着同步块，谁拿到这个锁谁就可以运行它所控制的那段代码。
	synchronized 会指定把obj锁定，当有Thread访问同步块时，要先获得该obj对象锁，否则被阻塞，直到obj对象锁被其他Thread释放。obj必需是多个Thread所访问到的同一个对象，Threads用同一把锁，同步块才能正常运作。	
	
wait（）会使线程释放获得的锁（线程放弃该锁）,进入锁的等待池 ;lock.notify() 唤醒等待该对象监听器的一条线程，使得等待池的一个线程进入锁池，等待获得锁，回到调用wait的现场

通常在while循环中用wait，条件满足则wait

sleep()/join(),不会释放线程获得的锁
	so在同步块里用join会造成死锁

interrupt()会中断lock.wait()/self.sleep()/other.join() 


volatile、synchronized 和 final 实现可见性
在 Java  synchronized 中和在 lock、unlock 中操作保证原子性。
volatile 和 synchronized 两个关键字来保证线程之间操作的有序性

可见性：
是指线程之间的可见性，一个线程修改的状态对另一个线程是一定可见的。也就是一个线程修改的结果。另一个线程马上就能看到。

原子性：
原子是世界上的最小单位，具有不可分割性。一个不可分割的操作叫原子操作。：a++ 由a+1和a=a+1俩步操作组成，非原子操作

有序性:
程序串行执行。

volatile :在类的属性声明中使用

	修饰被不同线程访问和修改的变量
	
	volatile只能让被他修饰内容具有可见性

volatile修饰的变量 [ 不允许线程内部缓存  和重排序 ]，即直接修改内存	
即只允许线程从主存中读写该变量，线程不保存备份 

volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢