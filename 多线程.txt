多线程：
	指的是这个程序（一个进程）运行时产生了不止一个线程.

并发：
	通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。

线程安全：
	一段代码在并发的情况下执行，经过多线程使用，线程的调度顺序不影响结果。线程不安全就意味着线程的调度顺序会影响最终结果。

同步：
	通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。在代码方法上加入synchronized关键字。
	方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中

阻塞
	其他阻塞：		//join，sleep，IORead/IOwrite	
		运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。
		sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态,等待系统调度运行

	等待阻塞：		//lock.wait()
		调用wait()，使该线程处于等待池,直到notify()/notifyAll()，线程被唤醒被放到锁定池，释放同步锁使线程回到可运行状态

	同步阻塞：		// synchronize
		运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
		进入可运行状态后等待cpu调度进入运行状态Running
		yield方法可以让一个running状态的线程转入runnable。
		
守护线程
	守护线程总是在其他非守护线程结束后才会结束

中断线程
	interrupt():若当前线程被阻塞则中断当前线程,
	isinterrupted:判断当前线程是否中断
	interrupted()检查当前线程是否发生中断，并清除中断状态
	中断是一个状态！interrupt()方法只是将这个状态置为true而已。
	

线程行为
	wait() 与 notify/notifyAll 方法必须在同步代码块中使用
	线程等待：
		Object类中的wait()方法，wait()也会让当前线程释放它所持有的锁
		导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法
		因为wait需释放锁，所以必须在synchronized中使用（没有锁定则么可以释放？没有锁时使用会抛出	IllegalMonitorStateException（正在等待的对象没有锁）

	线程唤醒：
		Object类中的notify()方法，唤醒在该对象的等待池中的线程

	线程让步：
		Thread.yield()
		转让cpu控制权，让别的就绪状态线程运行

	线程睡眠：
		public static Thread.sleep() 
		暂停一段时间
	　　　　
	线程加入：
		public join()
		在一个线程中调用其他线程otherthread.join(),将等其他线程执行完后才继续本线程。

-------------------------------------------------------------------------------------------------------------------
同步
	synchronize控制同步临界区的访问
	//基于监听器的同步及等待
		synchronized修饰:
			类方法(Class对象作锁)，方法(实例对象作锁)，同步块(可以指定任意对象作锁)
			构造方法不能使用synchronized关键字

		每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 

		synchronized(obj){} //obj的锁控制着同步块，谁拿到这个锁谁就可以运行它所控制的那段代码。
			synchronized 会指定把obj锁定，当有Thread访问同步块时，要先获得该obj对象锁，否则被阻塞，直到obj对象锁被其他Thread释放。obj必需是多个Thread所访问到的同一个对象，Threads用同一把锁，同步块才能正常运作。	
			
		wait（）会使线程释放获得的锁（线程放弃该锁）,进入锁的等待池 ;
			lock.notify() 唤醒等待该对象监听器的一条线程，使得等待池的一个线程进入锁池，等待获得锁，回到调用wait的现场

		sleep()/join(),不会释放线程获得的锁
			so在同步块里用join会造成死锁
	
	valitile变量
		volatile修饰的变量 [ 不允许线程内部缓存变量和指令重排序 ]，即直接修改内存	
			即只允许线程从主存中读写该变量，线程不缓存变量
			
		volatile :在类的属性声明中使用
			修饰被不同线程访问和修改的变量
			volatile只能让被他修饰内容具有可见性

		volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢
		
	volatile、synchronized 和 final 实现可见性
			在synchronized 中和在 lock、unlock 中操作保证原子性。
			volatile 和 synchronized 两个关键字来保证线程之间操作的有序性

		可见性：
			是指线程之间的可见性，一个线程修改的状态对另一个线程是一定可见的。也就是一个线程修改的结果。另一个线程马上就能看到。

		原子性：
			原子是世界上的最小单位，具有不可分割性。一个不可分割的操作叫原子操作。：a++ 由a+1和a=a+1俩步操作组成，非原子操作

		有序性:
			程序串行执行。

		缓存变量
			为提升性能，jvm会缓存线程的变量，将线程变量缓存在jvm的寄存器上或cpu的寄存器上
			volatile变量不会被缓存，直接读写内存

	死锁,活锁,饿死
		死锁:
			线程1的运行需要线程2持有的锁，而线程2的运行需要线程1持有的锁，
			结果，线程1等待线程2的锁，线程2等待线程1的锁，永远互相等待，造成死锁
		活锁：
			线程占用锁后总是重复运行一些不能结束的操作，像while(ture),使得线程占用锁一直运行却作无用功
		饿死:
			总是有高优先级的线程在运行，而使得低优先级的线程得不到运行的机会

等待和通知
	线程交互
		wait()：使持有锁的线程进入等待池等待
		notify()：使锁的等待池中的线程进入锁池，等待获得锁去执行
		notifyAll():使锁的等待池中的所有线程进入锁池，等待获得锁执行
	
	生产者与消费者问题
	
线程局部变量
	ThreadLocal<T> 
		定义一个存储线程变量的类，存储当前线程存入的值。每条线程存储与获取变量时，总会取得当前线程对应的那个值
	set()
		存入线程局部变量
	get()
		取得当前线程的局部变量，若线程的局部变量值不存在，则调用initialValue的值
	remove()
		移除ThreadLocal中所有线程额局部变量
	initialValue()
		初始化ThreadLocal,并赋null
	
定时器
	Timer()
		定时器，定期执行定时任务
	TimeTask()
		定时任务，是Runnable的一个抽象类
	





