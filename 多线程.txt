多线程：
	指的是这个程序（一个进程）运行时产生了不止一个线程.

并发：
	通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。

线程安全：
	一段代码在并发的情况下执行，经过多线程使用，线程的调度顺序不影响结果。线程不安全就意味着线程的调度顺序会影响最终结果。

同步：
	通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。在代码方法上加入synchronized关键字。
	方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中

阻塞
	其他阻塞：		//join，sleep，IORead/IOwrite	
		运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。
		sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态,等待系统调度运行

	等待阻塞：		//lock.wait()
		调用wait()，使该线程处于等待池,直到notify()/notifyAll()，线程被唤醒被放到锁定池，释放同步锁使线程回到可运行状态

	同步阻塞：		// synchronize
		运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
		进入可运行状态后等待cpu调度进入运行状态Running
		yield方法可以让一个running状态的线程转入runnable。
		
守护线程
	守护线程总是在其他非守护线程结束后才会结束

中断线程
	interrupt():若当前线程被阻塞则中断当前线程,
	isinterrupted:判断当前线程是否中断
	interrupted()检查当前线程是否发生中断，并清除中断状态
	中断是一个状态！interrupt()方法只是将这个状态置为true而已。
	

线程行为
	wait() 与 notify/notifyAll 方法必须在同步代码块中使用
	线程等待：
		Object类中的wait()方法，wait()也会让当前线程释放它所持有的锁
		导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法
		因为wait需释放锁，所以必须在synchronized中使用（没有锁定则么可以释放？没有锁时使用会抛出	IllegalMonitorStateException（正在等待的对象没有锁）

	线程唤醒：
		Object类中的notify()方法，唤醒在该对象的等待池中的线程

	线程让步：
		Thread.yield()
		转让cpu控制权，让别的就绪状态线程运行

	线程睡眠：
		public static Thread.sleep() 
		暂停一段时间
	　　　　
	线程加入：
		public join()
		在一个线程中调用其他线程otherthread.join(),将等其他线程执行完后才继续本线程。

-------------------------------------------------------------------------------------------------------------------
同步
	synchronize控制同步临界区的访问
		线程运行到同步临界区时，
		若获得了锁，则从内存中取回变量的值，存储到线程的缓存中，
		释放锁时再将同步块中的变量写到内存中，保证可见性 	//volatile唯一的作用
		线程取得锁期间执行的操作为原子操作，保证操作的原子性
	//基于监听器的同步及等待
		synchronized修饰:
			类方法(Class对象作锁)，方法(实例对象作锁)，同步块(可以指定任意对象作锁)
			构造方法不能使用synchronized关键字

		每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 

		synchronized(obj){} //obj的锁控制着同步块，谁拿到这个锁谁就可以运行它所控制的那段代码。
			synchronized 会指定把obj锁定，当有Thread访问同步块时，要先获得该obj对象锁，否则被阻塞，直到obj对象锁被其他Thread释放。obj必需是多个Thread所访问到的同一个对象，Threads用同一把锁，同步块才能正常运作。	
			
		wait（）会使线程释放获得的锁（线程放弃该锁）,进入锁的等待池 ;
			lock.notify() 唤醒等待该对象监听器的一条线程，使得等待池的一个线程进入锁池，等待获得锁，回到调用wait的现场

		sleep()/join(),不会释放线程获得的锁
			so在同步块里用join会造成死锁
	
	valitile变量
		volatile修饰的变量 [ 不允许线程内部缓存变量和指令重排序 ]，即直接修改内存	
			即只允许线程从主存中读写该变量，线程不缓存变量
			
		volatile :在类的属性声明中使用
			修饰被不同线程访问和修改的变量
			volatile只能让被他修饰内容具有可见性

		volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢
		
	volatile、synchronized 和 final 实现可见性
			在synchronized 中和在 lock、unlock 中操作保证原子性。
			volatile 和 synchronized 两个关键字来保证线程之间操作的有序性

		可见性：
			是指线程之间的可见性，一个线程修改的状态对另一个线程是一定可见的。也就是一个线程修改的结果。另一个线程马上就能看到。

		原子性：
			原子是世界上的最小单位，具有不可分割性。一个不可分割的操作叫原子操作。：a++ 由a+1和a=a+1俩步操作组成，非原子操作

		有序性:
			程序串行执行。

		缓存变量
			为提升性能，jvm会缓存线程的变量，将线程变量缓存在jvm的寄存器上或cpu的寄存器上
			volatile变量不会被缓存，直接读写内存

	死锁,活锁,饿死
		死锁:
			线程1的运行需要线程2持有的锁，而线程2的运行需要线程1持有的锁，
			结果，线程1等待线程2的锁，线程2等待线程1的锁，永远互相等待，造成死锁
		活锁：
			线程占用锁后总是重复运行一些不能结束的操作，像while(ture),使得线程占用锁一直运行却作无用功
		饿死:
			总是有高优先级的线程在运行，而使得低优先级的线程得不到运行的机会

等待和通知
	线程交互
		wait()：使持有锁的线程进入等待池等待
		notify()：使锁的等待池中的线程进入锁池，等待获得锁去执行
		notifyAll():使锁的等待池中的所有线程进入锁池，等待获得锁执行
	
	生产者与消费者问题
	
线程局部变量
	ThreadLocal<T> 
		定义一个存储线程变量的类，存储当前线程存入的值。每条线程存储与获取变量时，总会取得当前线程对应的那个值
	set()
		存入线程局部变量
	get()
		取得当前线程的局部变量，若线程的局部变量值不存在，则调用initialValue的值
	remove()
		移除ThreadLocal中所有线程额局部变量
	initialValue()
		初始化ThreadLocal,并赋null
	
定时器
	Timer()
		定时器，定期执行定时任务
	TimeTask()
		定时任务，是Runnable的一个抽象类


什么是CAS		//像hibernate通过version来加乐观锁一样  比较新旧？赋值更新：啥都不做
       CAS，Compare and Swap即比较并交换。 java.util.concurrent包借助CAS实现了区别于synchronized同步锁的一种乐观锁。
	   CAS有3个操作数：内存值V，旧的预期值A，要修改的新值B。
			V=V.equit(A)?B:V
	   CAS的关键点在于，系统在硬件层面保证了比较并交换操作的原子性，处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。
	ABA问题
		若一个变量由A变成B，再由B变成A，CAS的方法会认为变量的值无变化。
		解决:
			通过版本号来进行CAS，像hibernate通过version来对实体加乐观锁一样
			实现类:AtomicStampedReference
	使用场合
		1.CAS不适合竞争十分频繁的场景。
		2.CAS只能保证共享单一atomic类的原子性，当有多个共享的atomic被并发访问时，只能加同步锁访问
并发工具类	java.util.concurrent.*
	java.util.concurrent包
		并发编程中常用到的类，如：Executors
		
		Executor:
			执行单一的Runnable对象，无返回值
		ExecutorService:
			执行若干Runnable对象，无返回值
			执行若干Callable对象，有返回值，返回Future对象，保存了Callable的返回结果，进行异步通信
		ScheduleExecutorService：
			与ExecutorService类似
		
		ExecutorService使用
			execute()
			或
			submit()：执行若干Callable或Runnable对象并返回保存着结果的Future对象
		Future保存Callable返回的结果
			get()：取得Callable返回的结果
		Executor执行完后要关闭，否则里面的线程会一直占用资源
			shutdown()
			shutdownNow()
			
		
		Executors：	//
			取得多种Executor的子类的实例，关联到callable和future
			如：
			单一线程方式
				newSingleThreadExecutor()：创建只有一条线程的ExecutorService的实例
				newSingleThreadScheduledExecutor()：创建只有一条线程的ScheduleExecutorService的实例
			线程池方式
				newFixThreadPool(int n)：创建带有容量为n的线程池的ExecutorService的实例
				newScheduledThreadPool(int n)：创建带有容量为n的线程池的ScheduleExecutorService的实例
			
	java.util.concurrent.atomic包
		包提供了一系列原子类,用于并发访问
		在操作这些原子类时不会阻塞线程，因为没有用synchronize对其没有加同步锁访问，而是通过CAS乐观锁来保证变量的原子操作；
		
	java.util.concurrent.locks包
		锁框架，提供一种比加synchronize同步锁更灵活的加锁方式
		
	





