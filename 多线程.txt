多线程：
	指的是这个程序（一个进程）运行时产生了不止一个线程.

并发：
	通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。
	并发用于提高在单个cup上运行的程序的性能

线程安全：
	一段代码在并发的情况下执行，经过多线程使用，线程的调度顺序不影响结果。线程不安全就意味着线程的调度顺序会影响最终结果。

同步：
	通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。在代码方法上加入synchronized关键字。
	方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中

阻塞
	其他阻塞：		//join，sleep，IORead/IOwrite	
		运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。
		sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态,等待系统调度运行

	等待阻塞：		//lock.wait()
		调用wait()，使该线程处于等待池,直到notify()/notifyAll()，线程被唤醒被放到锁定池，释放同步锁使线程回到可运行状态

	同步阻塞：		// synchronize
		运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
		进入可运行状态后等待cpu调度进入运行状态Running
		yield方法可以让一个running状态的线程转入runnable。
		
守护线程
	守护线程总是在其他非守护线程结束后才会结束

中断线程
	interrupt():若当前线程被阻塞则中断当前线程,
	isinterrupted:判断当前线程是否中断
	interrupted()检查当前线程是否发生中断，并清除中断状态
	中断是一个状态！interrupt()方法只是将这个状态置为true而已。
	

线程行为
	wait() 与 notify/notifyAll 方法必须在同步代码块中使用
	线程等待：
		Object类中的wait()方法，wait()也会让当前线程释放它所持有的锁
		导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法
		因为wait需释放锁，所以必须在synchronized中使用（没有锁定则么可以释放？没有锁时使用会抛出	IllegalMonitorStateException（正在等待的对象没有锁）

	线程唤醒：
		Object类中的notify()方法，唤醒在该对象的等待池中的线程

	线程让步：
		Thread.yield()
		转让cpu控制权，让别的就绪状态线程运行

	线程睡眠：
		public static Thread.sleep() 
		暂停一段时间
	　　　　
	线程加入：
		public join()
		在一个线程中调用其他线程otherthread.join(),将等其他线程执行完后才继续本线程。

-------------------------------------------------------------------------------------------------------------------
同步
	synchronize控制同步临界区的访问
		线程运行到同步临界区时，
		若获得了锁，则从内存中取回变量的值，存储到线程的缓存中，
		释放锁时再将同步块中的变量写到内存中，保证可见性 	
		线程取得锁期间执行的操作为原子操作，保证操作的原子性
	基于监听器的同步及等待
		synchronized修饰:
			类方法(Class对象作锁)，方法(实例对象作锁)，同步块(可以指定任意对象作锁)
			构造方法不能使用synchronized关键字

		java中每个对象有一个监听器与之关联，哪条线程先锁住控制临界区的那个对象的监听器，就可以运行它所控制的那段代码。
		监听器是互斥的，只能由一条线程锁住，

		synchronized(obj){} //obj的锁控制着同步块，谁拿到这个锁谁就可以运行它所控制的那段代码。
			synchronized 会指定把obj锁定，当有Thread访问同步块时，要先获得该obj对象锁，否则被阻塞，直到obj对象锁被其他Thread释放。
			obj必需是多个Thread所访问到的同一个对象，Threads用同一把锁，同步块才能正常运作。	
			
		wait（）会使线程释放获得的锁（线程放弃该锁）,进入锁的等待池 ;
			lock.notify() 唤醒等待该对象监听器的一条线程，使得等待池的一个线程进入锁池，等待获得锁，回到调用wait的现场

		sleep()/join(),不会释放线程获得的锁
			so在同步块里用join会造成死锁
	
	valitile变量
		volatile修饰的变量 [ 不允许线程内部缓存变量和指令重排序 ]，即直接修改内存
			volatile关键字本身就包含了禁止指令重排序的语义
			即只允许线程从主存中读写该变量，线程不缓存变量
			
		作用:
			保证变量的可见性(直接读写内存，其他线程可见)与有序性(禁止JVM对变量的操作指令重排序，确保操作按顺序执行)
			
		volatile :在类的属性声明中使用
			修饰被不同线程访问和修改的变量
			volatile只能让被他修饰内容具有可见性

		volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢
		
	volatile、synchronized 和 final 实现可见性
	synchronized 中和在 lock、unlock 中操作保证原子性。或使用atomic类作变量保证操作原子性
	volatile 和 synchronized 两个关键字来保证线程之间操作的有序性

		可见性：
			是指线程之间的可见性，一个线程修改的状态对另一个线程是一定可见的。也就是一个线程修改的结果。另一个线程马上就能看到。
			变量的修改会被马上同步到内存

		原子性：
			原子是世界上的最小单位，具有不可分割性。一个不可分割的操作叫原子操作。：a++ 由a+1和a=a+1俩步操作组成，非原子操作，
			高并发操作a++时，会出错

		有序性:
			程序串行执行。保证对变量的操作是按照编写顺序执行的，使JVM不会对操作指令的执行顺序重排序

		缓存变量
			为提升性能，jvm会缓存线程的变量，将线程变量缓存在jvm的寄存器上或cpu的寄存器上
			volatile变量不会被缓存，直接读写内存

	死锁,活锁,饿死
		死锁:
			线程1的运行需要线程2持有的锁，而线程2的运行需要线程1持有的锁，
			结果，线程1等待线程2的锁，线程2等待线程1的锁，永远互相等待，造成死锁
		活锁：
			线程占用锁后总是重复运行一些不能结束的操作，像while(ture),使得线程占用锁一直运行却作无用功
		饿死:
			总是有高优先级的线程在运行，而使得低优先级的线程得不到运行的机会

等待和通知
	线程交互
		wait()：使持有锁的线程进入等待池等待
		notify()：使锁的等待池中的线程进入锁池，等待获得锁去执行
		notifyAll():使锁的等待池中的所有线程进入锁池，等待获得锁执行
	
	生产者与消费者问题
	
线程局部变量
	ThreadLocal<T> 
		定义一个存储线程变量的类，存储当前线程存入的值。每条线程存储与获取变量时，总会取得当前线程对应的那个值
	set()
		存入线程局部变量
	get()
		取得当前线程的局部变量，若线程的局部变量值不存在，则调用initialValue的值
	remove()
		移除ThreadLocal中所有线程额局部变量
	initialValue()
		初始化ThreadLocal,并赋null
	
定时器
	Timer()
		定时器，定期执行定时任务
	TimeTask()
		定时任务，是Runnable的一个抽象类



并发工具类	java.util.concurrent.* 	//为了不用synchronized来处理并发访问，提高性能
	其里面的Lock锁，atomic都是建立在CAS上的
	什么是CAS		//像hibernate通过version来加乐观锁一样  比较新旧？赋值更新：啥都不做
		CAS，Compare and Swap即比较并交换。 java.util.concurrent包借助CAS实现了区别于synchronized同步锁的一种乐观锁。
		CAS有3个操作数：内存值V，旧的预期值A，要修改的新值B。
			V=V.equit(A)?B:V
		CAS的关键点在于，系统在硬件层面保证了比较并交换操作的原子性，处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。
		ABA问题
			若一个变量由A变成B，再由B变成A，CAS的方法会认为变量的值无变化。
			解决:
				通过版本号来进行CAS，像hibernate通过version来对实体加乐观锁一样
				实现类:AtomicStampedReference
		使用场合
			1.CAS不适合竞争十分频繁的场景。
			2.CAS只能保证共享单一atomic类并发访问的原子性，当有多个共享的atomic被并发访问时，只能加同步锁访问
	乐观锁
		乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。
		其实现过程就是CAS
		
	java.util.concurrent包
		并发编程中常用到的类，如：Executors
		
		Executor:
			执行器接口
			执行单一的Runnable对象，无返回值
		ExecutorService:
			执行若干Runnable对象，无返回值
			执行若干Callable对象，有返回值，立即返回Future对象，用于跟踪若干个异步线程任务的处理，保存了Callable的返回结果，进行异步通信
		ScheduleExecutorService：
			与ExecutorService类似
		
		ExecutorService使用
			execute()
			或
			submit()：执行若干Callable或Runnable对象并返回保存着结果的Future对象
		Future
			功能：
				保存Callable返回的结果，取消线程任务，判断任务是否完成
			get()：取得Callable返回的结果
			cancle()：取消任务
			isDone()：判断是否完成任务
			
		Executor执行完后要关闭，否则里面的线程会一直占用资源
			shutdown()
				shutdown后的Executor将不再就受新的任务。强行submit会抛出RejectedExecutionException
			shutdownNow()
				shutdownNow后的Executor将不再就受新的任务,并且取消正在执行的task。
				抛出CancellationException，强行submit会抛出RejectedExecutionException
				
		Executors：	//
			一个工厂类，用于创建Executor，ExecutorService，ScheduleExecutorService，ThreadFactory
			用于取得多种Executor的子类的实例，关联到callable和future
			如：
			单一线程方式
				newSingleThreadExecutor()：创建只有一条线程的ExecutorService的实例
				newSingleThreadScheduledExecutor()：创建只有一条线程的ScheduleExecutorService的实例
			线程池方式
				newFixThreadPool(int n)：创建带有容量为n的线程池的ExecutorService的实例
				newScheduledThreadPool(int n)：创建带有容量为n的线程池的ScheduleExecutorService的实例
			
	java.util.concurrent.atomic包
		包提供了一系列原子类,用于并发访问，实现原子性与可见性
		在操作这些原子类时不会阻塞线程，提高性能，因为没有用synchronize对其没有加同步锁访问，而是通过CAS乐观锁来保证变量的原子操作；
		
		atomic类的CAS
			修改atomic变量的值时，通过unsafe.compareAndSwapInt()来进行操作，保证操作原子性
			
	java.util.concurrent.locks包
		Lock接口	//取代synchronize
			锁框架，提供一种比加synchronize监听器关联的锁更灵活的并发访问加锁操作
			方法：
				lock()	：线程取得锁，若锁不可用则被阻塞一直等待
				tryLock()：尝试取得锁，若成功取得则返回ture，否则返回false，不用等待获得锁
				unlock():释放获得的锁，若线程没持有锁却释放，抛出IllegalMonitorStateException，在finally中unlock(),以防止死锁
			
			ReentrantLock重入锁
				Lock的一个实现，持有一个计数器，记录着该锁的被lock多少次，允许同一线程多次加锁lock()
				线程调用加锁方法（lock，tryLock，lockInterruptily）时，持有量+1，调用unlock()时，持有量-1，持有量减为0时，线程释放该锁
				其控制高并发的方式是CAS的实现，因此比synchronized有更高性能
				
				fair/unfair
					公平模式：
						线程想取得锁，若锁不可用则进入ReentrantLock的等待队列，即线程会保存到一个FIFO的Queue中
						,等待时间最长的线程首先获得锁，先进先出
					非公平模式：
						线程想取得锁，若锁不可用则等待，所有线程尽可能快地取得锁，
						有可能同一线程能连续获得锁，而等待了很久的线程迟迟不能取得锁
						
				方法：
					isLocked():判断有any线程取得锁
					isHeldByCurrentThread()：判断当前线程是否取得锁
					lock.getHoldCount():返回持有量
			
		ReadWriteLock接口
			用于对数据频繁读取而较少修改的场合，此时能比Lock锁有更高的性能
			读写锁持有一对关联的锁Lock-----ReadLock和WriteLock
				ReadLock
					是一个Lock类
					非互斥锁，读锁只锁定读操作，同一读锁可被多条线程持有
				WriteLock
					是一个Lock类
					互斥锁，写锁只锁定写操作，同一时间只能被一条线程持有
			
				ReadWriteLock的writeLock被线程持有时，其他线程不能获得同一ReadWriteLock的任何锁
				ReadWriteLock的readLock被线程持有时，其他线程不能获得同一ReadWriteLock的writeLock锁，但可以获取readLock
			
			方法：
				readLock():取得读锁
				writetLock():取得写锁
				
			ReadWriteReentrantLock重入读写锁
				实现ReadWriteLock接口	，其中的ReadLock与WriteLock的实现是其实现了Lock接口的内部类
				持有两个计数器读锁计数器，写锁计数器，记录着该读写锁的被lock多少次，允许同一线程多次加锁lock()
				
				方法：
					getReadHoldCount():取得读锁持有量
					getWriteHoldCount():取得写锁持有量
								
		Condition	//取代Object的wait,notify()和notifyAll()，配合Lock使用
			通过LockInstance.newCondition()取得Condition
			使用
				用while（Condition），当满足某条件时使用await，使获得Lock的线程进入等待池
			方法
				await():使当前获得Lock的线程释放Lock，进入等待池一直等待
				signal():唤醒一个等待中的线程，
				signalAll():唤醒所有等待中的线程
			
			用于生产者/消费者
				
			
	





