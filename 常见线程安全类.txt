http://blog.csdn.net/dgeek/article/details/70145555

1   Timer，TimerTask，Vector，Stack，HashTable，StringBuffer
--------->通过synchronized 关键字给方法加上内置锁来实现线程安全
    

2  Collections中的synchronizedCollection(Collection c)方法可将一个集合变为线程安全，
--------->其内部通过synchronized关键字加锁同步

3   原子类Atomicxxx―包装类的线程安全类
    如AtomicLong，AtomicInteger等等
--------->Atomicxxx 是通过Unsafe 类的native方法实现线程安全的

4   BlockingQueue 和BlockingDeque
    BlockingDeque接口继承了BlockingQueue接口，
    BlockingQueue 接口的实现类有ArrayBlockingQueue ，LinkedBlockingQueue ，
    PriorityBlockingQueue而BlockingDeque接口的实现类有LinkedBlockingDeque
    BlockingQueue和BlockingDeque 都是通过使用定义为
--------->final的<ReentrantLock>作为类属性显式加锁实现同步的

5   ThreadPoolExecutor
--------->ThreadPoolExecutor也是使用了<ReentrantLock>显式加锁同步

6   CopyOnWriteArrayList和 CopyOnWriteArraySet
--------->CopyOnWriteArraySet的内部实现是在其类内部声明一个final的CopyOnWriteArrayList属性，
    并在调用其构造函数时实例化该CopyOnWriteArrayList，CopyOnWriteArrayList采用的是显式地加上ReentrantLock实现同步，
    而CopyOnWriteArrayList容器的线程安全性在于在每次修改时都会创建并重新发布一个新的容器副本，从而实现可变性。

7   Concurrentxxx
    最常用的就是ConcurrentHashMap，当然还有ConcurrentSkipListSet和ConcurrentSkipListMap等等。
    ConcurrentHashMap使用了一种完全不同的加锁策略来提供更高的并发性和伸缩性。
    ConcurrentHashMap并不是将每个方法都在同一个锁上同步并使得每次只能有一个线程访问容器，
    而是使用一种粒度更细的加锁机制
--------->――分段锁来实现更大程度的共享

    在这种机制中，任意数量的读取线程可以并发访问Map，执行读取操作的线程和执行写入操作的线程可以并发地访问Map，并且一定数量的写入线程可以并发地修改Map，这使得在并发环境下吞吐量更高，而在单线程环境中只损失非常小的性能





