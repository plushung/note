获取sessionFactory对象

从sessionFactory中取得session

取得trancaction开始事务，beginTrancaction()

JPA
	通过JDK 5.0注解或XML描述对象－关系表的映射关系，将实体映射成数据库的表
	持久化上下文EntityManager由JPA创建
	
JTA
	Java Transaction API，译为Java事务API。JTA允许应用程序执行分布式事务处理,决定持久化何时提交到数据库
	每个事务Transaction由JTA创建

用session执行查询
	1.用Criteria对象进行标准查询
		Criteria cr=s.createCriteria(Spittle.class);
		userlist=cr.list()
	或
	2.通过hql语句查询
		String hql=“from 持久类类名”
		Query q=Session.createQuery(hql)
		q.list()
	或
	3.用sql语句查询
	
trancaction 提交事务或回滚
	session在trancaction提交或回滚时，由hibernate框架管理关闭，我们不用手动关闭session
	
	同一id的数据库对象在一次事务中只能存在一个
	？？为什么我们没有自己关闭session
		hibernate框架会维护这个session，他会在你事务提交的时候关闭session。

Hibernate 架构	
	1.Configuration对象
		表示Hibernate的配置包括实体类映射配置(Entity.hbm.xml),和数据库配置(hibernate.cfg.xml | hibernate.porperties)
		包含两种组件
			数据库连接(hibernate.cfg.xml / hibernate.porperties)
				用以配置数据库链接
			实体类映射
				用于配置java对象与数据库的映射
	2.sessionFactory对象
		线程安全的，由Configuration对象创建，SessionFactory 在同一个application中一般只有一个，
		一个SessionFactory对应一种数据库的配置
	3.Session对象		//这是一个持久化上下文，为实体的持久化提供环境
		Session对象用于保存和检索持久化对象，与数据库进行交互，是持久化的上下文
		Session由SessionFactory对象创建，session会在内存中缓存他实例化过的持久化实体实例(一级缓存)
	4.Transaction对象
		一个事务代表了与数据库工作的一个单元，进行数据库事务commit或rollback
		在 Hibernate 中事务由底层事务管理器（transactionManager）和事务(transaction)（来自 JDBC 或者 JTA）处理
	5.Criteria对象
		用于创造与执行面向规则的对象 来查询对象
	6.Query对象
		使用SQL或HQL执行CRUD操作
		
	Session接口　
		Session接口负责执行被持久化对象的CRUD操作,是非线程安全的
	SessionFactory接口　
		SessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建Session对象。一个项目通常只需要一个SessionFactory
	Configuration接口　
		Configuration接口负责配置并启动Hibernate，创建SessionFactory对象。
		
	上下文相关的会话（Contextual Session）
		特定的会话在整个特定的上下文范围内始终有效。就是session的运行环境，Session的上下文可以是一个Transaction的范围，可以是一个线程的范围，等等
		session在这些上下文范围内有效
		
		hibernate 3.0.1 版本开始，Hibernate 增加了 SessionFactory.getCurrentSession()，默认用JTA定义Session的上下文。
		
		hibernate 3.1 开始 新的扩展接口（org.hibernate.context.CurrentSessionContext）和新的配置参数（hibernate.current_session_context_class）
		，session的范围与上下文的定义可以实现热拔插了，随时可换上下文
		也就是说可以通过current_session_context_class参数去灵活定义Session的上下文
		current_session_context_class 配置参数定义了应该采用哪个 org.hibernate.context.CurrentSessionContext 实现。
			参数的值指明了要使用的实现类的全名
			可以用"jta"、"thread" 和 "managed"3个简写分别对应内置的3个Context

配置
	1 Configuration
		用来构建一个（不可变的（immutable））org.hibernate.SessionFactory
		实例化一个Configureation对象
		1.指定 XML 映射定义文件
			addSource("***.xml")
			addSource(***.class)
			或在配置文件上<mapping>配置映射
			或直接通过注解扫描配置映射
		2.指定配置属性
			setProperty("hibernate.dialect","org.hibernate.dialect.MySQLInnoDBDialect")
			或在hibernate.cfg.xml/hibernate.properties配置文件上配置属性
		
	2 SessionFactory		//表示一个持久化单元或逻辑数据库
		SessionFactory被应用的所有线程共享
		3.通过Configuration对象的取得SessionFactory
			Configureation.buildSessionFactory();
			
	3 Session（jdbc连接）		//这是一个持久化上下文，为实体的持久化提供环境
		前提是配置好数据源或JDBC
		4. SessionFactory.openSession()
			SessionFactory会从连接提供器(ConnectionProvider)中获得一个JDBC连接。
			
			1.hibernate.connection.pool_size 是hibernate自带的，可用c3p0连接池替代
				在hibernate.connection.pool_size的位置用c3p0的配置替代即可
					hibernate.connection.driver_class = org.postgresql.Driver
					hibernate.connection.url = jdbc:postgresql://localhost/mydatabase
					hibernate.connection.username = myuser
					hibernate.connection.password = secret
					hibernate.c3p0.min_size=5
					hibernate.c3p0.max_size=20
					hibernate.c3p0.timeout=1800
					hibernate.c3p0.max_statements=50
				如果设置了 hibernate.c3p0.* 相关的属性，
				Hibernate将使用 C3P0ConnectionProvider 来缓存 JDBC 连接，openSession()将从其中取得连接
			
			1.配置成从注册在 JNDI 中的 Datasource 处获得连接
				属性
					hibernate.connection.datasource = java:/comp/env/jdbc/test
					hibernate.connection.datasource	数据源 JNDI 名字
					
			1.通过实现 org.hibernate.connection.ConnectionProvider 接口，定义属于你自己的获得JDBC连接的插件策略
				hibernate.connection.provider_class，选择一个自定义的实现类，为hibernate提供jdbc连接
		
		4. SessionFactory.getCurrentSession()
			会从CurrentSessionContext对象中取得连接，该连接由SessionContext管理，不用手动close
			sessionContext可以是Jta，Thread，managed分别有JTA
			若没配置CurrentSessionContext，但配置了JTA事务，hibernate则会默认使用JTASessionContext来作为CurrentSessionContext的配置
		
	4可选的配置属性
		常用:	
			配置属性
				hibernate.dialect					//允许 Hibernate 针对特定的关系数据库生成优化的 SQL
				hibernate.show_sql				//输出所有 SQL 语句到控制台
				hibernate.session_factory_name		//SessionFactory 创建后，将自动使用这个名字绑定到 JNDI 中。 
				hibernate.default_batch_fetch_size		//为 Hibernate 关联的批量抓取设置默认数量。例如：建议的取值为 4，8，和 16 
			
			JDBC 和连接（connection）相关属性
				hibernate.default_batch_fetch_size 		//关联的批量抓取设置，建议的取值为 4，8，和 16，就是每次从关联记录中去多少记录 int
				hibernate.jdbc.fetch_size			//指定每次从JDBC抓取数量的大小（调用 Statement.setFetchSize()）	int
				hibernate.jdbc.batch_size			//允许 Hibernate 使用 JDBC2 的批量更新,即hibernate每产生n条更新语句，就向JDBC提交一批语句
				hibernate.connection.provider_class		//指定自定义的Connection提供类，向Hibernate提供JDBC链接	Class
				
			缓存相关属性
				hibernate.cache.provider_class		//指定自定义的CacheProvider的类名,为hibernate提供二级缓存 ：Class
				hibernate.cache.use_query_cache		//允许查询缓存，个别查询仍然需要被设置为可缓存的。例如：true | false 
				hibernate.cache.use_second_level_cache	//允许二级缓存，对那些在类的映射定义中指定 <cache> 的类，会默认开启二级缓存。 
				
			事务属性
				hibernate.transaction.factory_class		//一个 TransactionFactory 的类名，用于 Hibernate Transaction API（默认为 JDBCTransactionFactory）。
				
			其他属性
				hibernate.current_session_context_class	//自定义session的上下文 例如：jta | thread | managed | custom.Class 
				hibernate.query.factory_class			//选择HQL解析器的实现
				hibernate.hbm2ddl.auto				//| validate 	验证创建数据库表结构，若实体类与表结构不同，就报错
											//| update 		只是更新数据不会更改表结构,即删除表后会恢复
											//| create 		每次加载hibernate，如果数据库中存在表，将所有表删除，然后重新生成表
											//| create-drop	加载hibernate时创建，退出时删除表结构，数据库中原本有几个表就有几个表
											
			 
			JNDI 绑定的 SessionFactory
			
事务与并发
	session的begainTransaction（）过程
		1确定事务的提供者
			在cfg.xml的SessionFactory中定义的hibernate.transaction.factory_class，指定了谁提供事务连接给Session
		2.取得事务
			由session所在的上下文(context),决定是否创建一条transaction
			若session所在的上下文已经有hibernateTransaction的一个实例则直接返回这条事务
			若session所在的上下文没有hibernateTransaction实例
			则由上下文取得transactionFactory的引用，并创建一个hibernateTransaction实例返回给session
		
		session——————>beginTrransaction————>getTransaction----->begin---->return to session
								   ||
								   V
								   context---->getTransaction----transaction!=null---->return transaction
												    |-----transaction=null----->gettransactionFactory
																		|------>createTransaction----->return transaction 
		session的4个阶段												
		    同步 session（flush，刷出到磁盘）
			提交事务
			关闭 session
			处理异常 
		
	事务管理方式：事务工厂transactionFactory有3种	
		事务策略配置
			hibernate的transaction
				org.hibernate.Transaction统一了各种事务的具体实现，可方便决定用哪种事务
			
			指定Transaction工厂类
				设置 Hibernate 配置属性 hibernate.transaction.factory_class 来指定一个 Transaction 实例的工厂类，
			
			Transaction工厂类作用
				产生transaction,决定session用谁的transaction来对数据库操作
			
			有三个TransactionFactory标准（内建）
				默认用org.hibernate.transaction.JDBCTransactionFactory
					使用JDBC事务的工厂，即本地资源事务（RESOURCE_LOCAL）
				org.hibernate.transaction.JTATransactionFactory
					使用JTA事务管理
					如果在上下文环境中存在运行着的事务（如，EJB 会话 Bean 的方法），则委托给容器管理的事务。
					否则，将启动一个新的事务，并使用 Bean 管理的事务。
				org.hibernate.transaction.CMTTransactionFactory
					使用容器管理的事务的工厂，
					事务的开始、提交、回滚交给容器决定
	
	事务管理
		hibernate是对JDBC的轻量封装，本身并不对事务进行管理
		JDBC事务		JDBCTransactionFactory
			JDBC可以处理单数据源的事务，只能对应一个数据库的事务
			由程序员手动管理事务(管理事务的begin、commit、rollback)
				0.加载数据库驱动class.forname()
				1.配置DriverManager，包括数据库的地址密码用户名，
				2.从DriverManager中取得Connection
				3.执行查询
				4.用Connection对象实现事务，commit，rollback
			顺序
				getSession-->beginTransaction--->transaction.commit---->session.close 
				//若通过getcrrentsession()取得Session，commit会将session.close，在Transaction提交时，由上下文自动执行close
				//若通过opensession()取得Session，要手动session.close，再commit
		JTA事务		JTATransactionFactory
			通过JTA等的事务管理器取得数据库的连接，一条事务可以同时从多个数据源中取得连接，简单的说 jta是多库的事务 jdbc是单库的事务
			应用程序应该使用 UserTransaction.begin()、 UserTransaction.commit() 和 serTransaction.rollback() 
			顺序
				beginTransaction|--->getSession1---->session1.close-->|transaction.commit
						   |--->getsession2---->session2.close--->|
		容器事务		CMTTransactionFactory
			由应用服务器容器管理事务，取得事务
			事务由J2EE应用服务器提供的，由服务器（如tomcat）托管事务，这是一个基于JNDI的基于JTA的，相当复杂的API实现
			在服务器的<Context>中添加<transaction>，来使用容器事务
			<Transaction>添加一个资源工厂，用于对从 java:comp/UserTransaction 获得的 UserTransaction 接口进行实例化。
			不用编程式地begin()与commit()
	JTA管理事务过程
		新请求来了，
		事务管理器从连接池（c3p0）取得一条连接，并与session绑定
		session执行业务逻辑
		session结束
		事务管理器commit/rollback事务，不用关闭连接，由DataSource来处理
		事务管理器释放从连接池取得的连接
	
	事务与并发
		事务边界
			JTA编程式事务
				JTA标准化了事务管理与分布式事务，他begin(),与commit()系统事务，通过编程地begin()和commit()确定事务边界
				手动使用UserTransaction的begin()和commit()
				
			声明式事务
				在javaEE中可以通过声明的方式确定一个事务的边界，在DAO实现类上@Transactional，声明地区分事务边界
				
		控制并发访问
			数据库级别的事务隔离保障
				事务隔离问题（不隔离事务时发生问题）
					丢失更新
						无隔离的事务更新相同数据，先更新的数据被后更新的数据覆盖而丢失
					读脏数据
						事务A读取了事务B没提交的更新数据
					不可重复读
						事务A执行两次读取操作期间，事务B更新了数据，使事务A两次读取到的数据状态不同
					第二类丢失更新
						不可重复读的特例，事务B重写事务A更新的数据
					幻读
						事务A执行两次读取操作期间，事务B插入或删除了数据，使事务A两次读取到的数据数目不同
					
				数据库事务隔离级别
					1.读未提交		//解决丢失更新   	b事务可读不可写		
						事务A修改某行并未提交时，其他事务不可在这行进行写操作，只可以读操作，读写其他行不受影响
						读取时，其他事务可写可读，写入时，其他事务不可写只可读			1101	
					2.读提交		//解决读脏数据，		b事务不可读写		
						其他事务要等事务A的修改提交后才可读取A修改的行，读写其他行不受影响
						读取时，其他事务不可写只可读，写入时，其他事务不可写只可读		0101
					3.可重复读取	//解决不可重复读		a读时，b不可写		
						读取时，其他事务不可写只可读，写入时，其他事务不可写不可读		0100
					4.序列化		//解决幻读			其他事务不能对当前表作任何操作
						读写时，其他事务什么都不能做							0000
						
					1，2，3的隔离范围是同一行，4的隔离范围是同一个表
					
					#hibernate.connection.isolation 4 在hibernate配置文件中修改数据库的事务隔离级别
					
					jpa及hibernate会默认数据库用的是读未提交隔离级别，
					剩下不可重复读，读脏数据，幻读的问题由ORM框架解决
			
			框架提供的并发控制
				乐观锁并发控制 (原理通过version版本控制并发，不是真正的锁，只是框架提供的根据version字段控制并发的‘锁’)
					使用版本控制
						hibernate在刷新持久上下文进行updata和delete时通过select检测版本，
						若版本与之前取得的版本号不同或该行不存在，则抛出OptimisticLockException,表示之前加载的实体已被他人修改
						否则执行更新
					排除某属性的乐观锁
						若想修改某属性时不更新版本号或时间戳，则在属性上@OptimisticLock(exclude=true)
					
					1.启用版本号进行版本控制		//更新数据时更新版本号
						增加一个version，在version上@Version启用版本控制
						当hibernate检测到数据变脏后，更新version号，在执行updata和delete时比较version号，并更新版本号	
					(快的优先)先更新的事务被提交，后来更新的事务被rollback并抛出OptimisticLockException
					或
					2.使用时间戳进行版本控制
						在表上有一列存储最后修改的时间戳，在实体类上的对应Data属性上@version启用版本控制
						可选@Type(type="dbtimestamp"),让hinernate统一从数据库读取时间
					或	不用时间戳和版本号
					3.在类上@OpmisticLocking（type=ALL）
						在检索实例或刷型持久化上下文时对该实体的所有未修改属性检测与数据库上的对比，进行冲突检测
						type=dirty 选项只在多条事务同时修改同一行记录的同一字段的值时才检测冲突，多条事务可同时修改同一行
						
					4.手动检查版本				//使数据可重复读
						查询时加乐观锁，让hibernate在刷新时对查询过的记录执行select，对比每行版本号，若不同则抛出OptimisticLockException
						在Query中setLockMode(LockModeType.OPTIMISTIC)，在某个查询时用乐观锁
						该乐观锁只是hinernate对version的检测，没有正真涉及到锁
					或
					5.强制版本递增				//加载数据时递增版本号，更新时再递增版本号
						在加载实体实例时递增版本号，执行find（）时添加LockModeType.OPTIMISTIC_Force_increment参数
					(慢的优先)后来事务被提交，先前的更新被rollback并抛出OptimisticLockException
					
				显式悲观锁 (原理是通过数据库真正的锁控制并发，即在数据库事务上加锁，加的是真正意义上的锁)
					LockModeType.pessimistic_read:	确保可重复读
						在数据库执行查询时加读锁，其他事务只可读。或增加删除其他记录，但不能对加锁的那行修改
						锁定查询行
						mysql : hibernate对该模式的处理是查询时sql语句后加上“lock in share mode”，为查询的记录加读锁
					
					LockModeType.pessimistic_write:	确保可重复读，确保不会幻读，即串行化查询
						在数据库执行查询时加读写锁，其他事务不可读写，并且不可加sx锁
						锁定查询的行
						mysql : hibernate对该模式的处理是查询时sql语句后加上“for updata”，为查询的记录加写锁

持久化类
	
	实体类定义要求
		1.普通的pojo类(可以是一个接口，然后用<subclass> 来指定该接口的实际实现类。)，要有唯一的id作为主键
			！！！若主键设置为自动生成，那么新增记录时，id不能自己给，由数据库生成，若数据库没设置为唯一标识，不会自动生成主键
			！！！报主键不能为null错误，要在数据库配置id为主键标志--是
		2.实体类必需要有一个默认的构造方法
			因为hibernate通过 反射机制 创建实体类的实例
			
	继承
		子类也必须遵守第一条和第二条规则。它从超类 Cat 继承了标识属性
		
	实现 equals() 和 hashCode() 方法
		想把持久类的实例放入 Set 中（当表示多值关联时，推荐这么做），而且想重用脱管实例
		就要实现这两个方法，用于比较两数据库行形成的实体类是否等价，被添加到 Set，则在 Set 中只有一个元素
		实现方法:业务键值相等
			equals() 方法仅仅比较形成业务键的属性，即比较各列属性
		Hibernate 仅对那些持久化对象赋标识值
		
	动态模型
		hibernate的持久化实体不仅可以是POJO类，也可以映射成Map或Dom4j树模型
		映射配置
			将映射文件<class>声明 entity-name 来代替一个类名，使数据库的一个行映射成map，
			在程序运行时就可以用map来代替实体类
			
	3种状态
		瞬时态
			一个被new实例化的javaPOJO对象，并未与Session关联，在数据库中无记录
		持久态(与某个Session有关联)
			Session用save。saveOrUpdata方法处理瞬时态的对象，那么该对象就变为持久态，并拥有一个持久化标识（identifier）。
			或
			者session用Criteria从数据库检索一条记录并映射成一个java对象时，这个java对象是持久态的
			
			对处于持久态的对象的任何操作都会被Hibernate 监视任何改变并在后台隐式写的方式执行SQL，放在session的缓存区
			当Session flush的时候或事务提交时，就会同步内存状态（缓存）和数据库，同步更新到数据库
			
		脱管态（detached）
			从持久太脱离出来的由于session的close(),clear(),detach()使实例不再与Session关联的对象，
			此时实例对象的任何操作都不会记录进数据库，但数据库中已有记录
			session对脱管态对象用updata，使其重新变为持久态，只有用updata才能对对象在脱管态时的改动持久化到数据库
		删除态
			持久态或托管态被session的delete删除了，那么对象就成了删除态，此时数据库中没有该对象的记录，像临时态一样

对象/关系数据库映射基础		
	<hiberante-mapping>
		<class name="User" table="Usertable">
			<id name="Id" column ="id" generator="identity">
			<set name="Comments" table="User_Comments" >
				<key column="From_user_id">
				<one-to-many column="Comment_id" class="Comment">
	通过映射文件配置映射
		映射文件为***-hbm.xml
		<hibernate-mapping>
			<class name="javapojo"  table="usertable"> //javapojo类与usertable间的映射
				<id type=“int”> //主键映射，type指定类型
			O/R映射 
				<property>//非主键映射
			集合映射	(一切集合都是表)
				若pojo中有集合属性
					用<set>、<list>、<bag>，<map>与数据库的集合类字段建立映射
					set,list,collection,map
				值类型
					java中的基本元素类型int string。。。。
				值类型集合
					普通类型的集合
					<set name="emailAddresses" table="PERSON_EMAIL_ADDR">//该集合属性对应的关联表
						<key column="PERSON_ID"/>				//persion类在关联表对应的字段
						<element type="string" column="EMAIL_ADDR"/>	//基本元素类型的集合用<element>定义，column指定表中与Persion关联的字段，”string“是向你表明它是一个 Hibernate 的映射类型
					</set>									//包含的是String类型的集合
			
			关联映射 1-1 1-* *-1 *-* 	<set name table> <key> <*To* type column class>
				<many-to-one name=“father”></many-to-one>//与<porperty>差不多
				单向关联映射
					一个实体类与另一个实体类有关联，且他们关系是	
				单向 多对多关联(只要在一个实体类中设置关联映射)
					n:m实体关联需要一个关联表，
					由<set>元素的table属性指定映射的关联表
					<set>里的<key>元素表明当前实体类对应的是关联表的哪个标识符字段名
					而 event 一端的字段名是由 <many-to-many> 元素的 column 属性定义
					<set name="events" table="PERSON_EVENT">		//persion实体类的events集合属性对应着PERSON_EVENT这个关联表
						<key column="PERSON_ID"/>			//persion实体类对应的是关联表里的PERSON_ID字段
						<many-to-many column="EVENT_ID" class="Event"/>//关联表里的EVENT_ID字段对应的是Event实体类，并且Persion类与Event类是多对多关联的
					</set>								//包含的是实体类的集合
				双向 多对多关联(要在关联两边的实体类中都设置关联映射)
					<set name="participants" table="PERSON_EVENT" inverse="true">//event实体类的participants集合属性对应着PERSON_EVENT这个关联表
						<key column="EVENT_ID"/>			//persion实体类对应的是关联表里的PERSON_ID字段
						<many-to-many column="PERSON_ID" class="Person"/>//关联表里的PERSON_ID字段对应的是Person实体类，并且event类与persion类是多对多关联的
					</set>								//包含的是实体类的集合
					Event 映射文件里增加了 set 元素的 inverse="true" 属性。 这意味着在需要的时候，Hibernate 能在关联的另一端 — Person 类得到两个实体间关联的信息。
				
				单对多关联
					<set name="pages">						//pages集合的关系映射
						<key name="OwnerId">				//对应pageItem中的OwnerId
						<one-to-many class="PageItem">			//每个user对应多个PageItem
				
				总结:！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
					映射文件中在<set>等集合元素配置的 必需是*对多关联 ，因集合变量存放多个关联的对象
					不在<set>等集合元素中配置的关联  只能是*对一关联 ，因一个非集合变量只存放一个关联对象
					单向关联只要在关联的一端配置映射
					双向关联要在关联的两端都配置映射，且要在集合属性上配置inverse=“true”属性
					必要时table属性指明保存两者关联关系的那个表
					*对多关联中，<key>表示‘我‘在关联表中是哪个列,class属性表示关联的是哪个实体
			
			组件映射 对应数据库中与另一个表的关联
				属性是另一种POJO类(组件类)，由另一种POJO类构成当前的实体类(组件映射)
				如果引用的类没有自己的生命周期并且完全依靠于拥有它的那个实体类的生命周期的话，
				那么这个引用类因此就可以叫做组件类。
				<Component Mappings>
	
	通过注释配置映射
		先导入依赖包hibernate-annotations.jar, lib/hibernate-comons-annotations.jar 和 lib/ejb3-persistence.jar
		类级注释
			@SubSelect（“SQL”）
				子查询，形成一个视图，hibernate从该视图中查询
			@Entity
				在类上使用表示该类为持久类
				被注释的类要有一个没有参数的构造函数并且在可保护范围是可见
			@Table(name = "EMPLOYEE")
				在持久类上使用表示该持久类映射的表“EMPLOYEE”
			
			@OptimisticLocking (type = OptimisticLockType.ALL)  保证数据在某个操作过程中不会被外界修改
			public class EmployeeEntity implements Serializable 
				type:
					version（版本检查）：只检查 version/timestamp 字段,即检查有@javax.persistence.Version的字段
					all（全部）：检查全部字段
					dirty（脏检查）：只检察修改过的字段，允许某些并行更新
					none（不检查）：不使用乐观锁定
				建议对version/timestamp 字段来进行乐观锁定。这个选择可以优化性能
				在version/timestamp属性上@Version，使之成为数据状态标识
			
			@synchronize
				定义这个实体所用的表为同步（synchronize），确保自动刷新（auto-flush）正确执行，并且依赖原实体的查询不会返回过期数据
			
			@AttributeOverrides({		//在子类上使用时，将重写父类属性到表的映射字段
							  @AttributeOverride(name="key.street1", column=@Column(name="fld_street")),
							  @AttributeOverride(name="value.stars", column=@Column(name="fld_note"))
						   })
						   
			@MappedSuperClass
				在父类上使用，使子类继承父类的所有字段，在子类上可以用@AttributeOverride重写字段映射
					可选在父类上声明数据库标识符
				
			@lazy
				延迟加载（Lazy fetching）
				
			@entity-name（default=classname）map、xml
				决定将实体映射成什么 ：类 or Map or Xml
			
			@subclass
				为接口的持久类指定实现类
		成员级注释
			@Id 和 @GeneratedValue 
				属性
					column:指定主键字段的名字
				@id注明的属性是表中的主键，主键可以是一个字段或者是多个字段的组合，这取决于你的表的结构。
				@GeneratedValue自动生成主键
				
			@Column
				指定某个属性与数据库某个字段的映射
					name 属性允许显式地指定列的名称。
	
	！映射定义（Mapping declaration）
		1实体
			@Entity
				在类上使用表示该类为持久类
				被注释的类要有一个没有参数的构造函数并且在可保护范围是可见
		
		2标识符Identifiers
			@id
				指定某成员属性为id，类型为基本类型的包装类
				
			复合主键
				@EmbeddedId
					指定类型为某个@Embeddable类的属性为id
					
				@Embeddable
					把某个类声明为可嵌入的，用来做嵌入id
			
			id生成器
				@GeneratedValue	//默认jpa自动生成值，由数据库来生成值，要在数据库配置
				或
				@GeneratedValue(generator="tor")	//配置生成器
				@GenericGenerator(name="tor",strategy="sequence",pamarter={})//用hibernate定义id生成器
				
			
		3乐观锁定的属性 为了防止同一实体类被不同的会话更新到数据库
			一个脱管（detached）实例的 version 或 timestamp 属性不能为空（null）
			要定义一个不能为空的 version 或 timestamp 属性
			
			Version number
				@Version				
					使用指定某属性为版本号		//对应表上的一个数值类型的version列
				参数
					column="version_column"				//指定持有版本号的字段名
					name="propertyName"
					type="typename"						//默认是integer，版本号的类型
					access="field|property|ClassName"
					unsaved-value="null|negative|undefined"		//用于标明某个实例时刚刚被实例化的（尚未保存）版本属性值
					generated="never|always"				//表明此版本属性值是否实际上是由数据库生成的
					insert="true|false"
					node="element-name|@attribute-name|element/@attribute|."
					
			timestamp						//对应表上的一个日期类型的timestamp列
				@Version	//注解方式同样用@version，不过type只能是Date or Calendar
					type类型为Date or Calendar
				或
				<timestamp
						column="timestamp_column"				//存有时间戳的字段名,默认是属性名
						name="propertyName"
						access="field|property|ClassName"
						unsaved-value="null|undefined"
						source="vm|db"
						generated="never|always"				//指出时间戳值是否实际上是由数据库生成的
						node="element-name|@attribute-name|element/@attribute|."
				/>
		
		4普通字段 Property
			@Transient
				表示该属性不是表中的字段，只是用来临时使用的，不会持久化到数据库，即不将该字段序列化到数据库
			@Basic
				属性的默认注解，即未加@Column的属性，对应表的字段，fetch = FetchType.LAZY用来设置懒加载
			@Lob 
				注解属性将被持久化为(byte log)Blog 或 (char lob)Clob 类型，Byte[], char[] ,存放大数据的类型
				@Basic、lob、column
				int getLength()
			@type(type="")
				为属性指定类型 可以使基本类型integer, string, character,date, timestamp, float, binary, serializable, object, blob
				或复合类型
				或一个可以序列化的 Java 类的名字。
			@Column
				name="columnname"	//指定该属性映射的字段名
				nullable = false		//是否可以为null
			@Formula(value="(select count(p.PageId) from pagetable p where p.OwnerId=id)")
				当hibernate访问数据库时，执行该SQL语句并将查询值赋值给被注解的属性
				
			xml
				<property
					name="propertyName"		//属性的名字
					column="column_name"		//对应的数据库字段名，或用<column>标签进行详细的属性配置
					type="typename"			//一个 Hibernate 类型的名字
					update="true|false"
					insert="true|false"
					formula="arbitrary SQL expression"
					access="field|property|ClassName"
					lazy="true|false"		//指定实例变量第一次被访问时，这个属性是否延迟抓取
					unique="true|false"		//使用 DDL 为该字段添加唯一的约束
					not-null="true|false"		//使用 DDL 为该字段添加可否为空（nullability）的约束
					optimistic-lock="true|false"	//指定这个属性在做更新时是否需要获得乐观锁
					generated="never|insert|always"//表明此属性值是否实际上是由数据库生成的
				/>
				
		5组件
			组件类的属性约束只能在Column中用nullable添加
			将某类定义为组件并声明为实体类的组件属性，是 值类型
				@Embeddable
					将类声明为复合类（组件），有多个属性
					可指定@Column属性设置列的相关属性，按照我们设定的值去生成表的字段
				@Embedded
					在一个属性中使用复合（组件）类型
					@AttributeOverrides
						在@Embedded属性中使用，覆盖@Embeddable的列属性，包含多个@AttributeOverride
					@AttributeOverride
						 @AttributeOverride(name="city", column = @Column(name = "person_city", length = 15))})
						 定义如何覆盖@Embeddable类的属性，
						 name	//指明覆盖的属性名
						 column	//指明被覆盖的属性映射成表中的什么字段名
					@AttributeOverrides({
						  @AttributeOverride(name="key.street1", column=@Column(name="fld_street")),
						  @AttributeOverride(name="value.stars", column=@Column(name="fld_note"))
					   })	
				组件可嵌套
			xml
				<component name="name" class="Name" unique="true">
				//name 	实体类中的组件属性名
				//class	组件的类名
					<parent name="owner"/>
					<property name="first" />
					<property name="last" />
				</component>
					
		6.枚举
			在枚举属性上@Enumerated（EnumType.SSTRING）,并设置枚举量要映射成数据库上的什么类型
		
		7.时序属性
			jap说明时序属性要有@Temporal()
			可以用hibernate的
			@CreationTimestamp（），自动产生一个时间
	
	！映射继承关系
		@AttributeOverrides({		//在子类上使用时，将重写父类属性到表的映射字段
			  @AttributeOverride(name="key.street1", column=@Column(name="fld_street")),
			  @AttributeOverride(name="value.stars", column=@Column(name="fld_note"))
						   })
		1:@MappedSuperClass								//只要维护子表，没有父表。对多关联时，不能用这种继承方式，必需用下面的
			在父类上使用，使子类继承父类的所有字段，在子类上可以用@AttributeOverride重写字段映射
				可选在父类上声明数据库标识符id
		或			
		每个子类各有一个表
		2:@Entity+@Inheritance(strategy="Table_Per_Class")			//只要维护子表，父表是空的
			在父类上使用，使子类继承父类的所有字段,
				从不同的子表select出需要的字段通过union 子表 as 父表
			！！用这种方法，必需要在父类上定义数据库标志符，所有子类共享标志符
			这种策略的子类的表之间没有关系，互不关联，子类表还是独立的，父类实体是通过子表的union操作构成的
		或
		所有子类公用一个父类表		//不推荐
		3:@Entity+@Inheritance(strategy="Single_table")				//只要维护一个表
			在父类上使用，使子类继承父类的所有字段,
			！！用这种方法，必需要在父类上定义数据库标志符，所有子类共享标志符
			要父类配置识别器@DiscriminatorColumn(name="By_TYPE") //用于识别不同的子表的识别值，来区分子表，hibernate 会在表上创建一个By_Type字段
			同时在子类上用@DiscriminatorValue（"CC"）			//为子表赋予一个不同的识别值作为BY_Type的值，通过By_type字段区分子类
			通过条件where By_type="son"取出子类记录
		或
		4:@Entity+@Inheritance(strategy="Inheritancetype.joined")		//要维护父表与子表
			在父类上使用，使子类继承父类, 通过联结的形式(inner join),构成表
				父表 inner join 不同的子表	= 表
			！！用这种方法，必需要在父类上定义数据库标志符，所有子类共享标志符
			子类表引用父表的外键约束，可用@PrimaryKeyColumn指定外键列作主键
			子表的主键是外键，父表的主键做子表的外键
		
	！Hibernate 的类型 
		实体（Entities）类型和值（values）类型
			实体的持久状态包含指向其他实体和值类型实例的引用，实体有独立标识，对应数据库中的一个表
			值对象是随着包含他们的实体而被持久化和删除的，值没有独立的标识，不对应表，是实体属性的成分
			组件就是用户自定义类，却是值语义的，属于值类型，组件随实体类被持久化和删除
		基本值
			integer,long,float,double,character,byte,boolean,yes_no,true_false
			String--->VARCHAR
			java.util.Date----->time,timestamp,data
			BigDecimal ,BigInteger------>NUMERIC
			binary字节数组----->SQL 二进制类型
		组件类型（Composite types）
		集合类型 Collection types
		实体类型Entity types
	
	！多次映射同一个类
		指定 entity name 来区别不同映射实体的 对象实例，通过实例名多次映射
		<class name="Contract" table="Contracts"
        entity-name="CurrentContract">
	
	！集合映射		//在集合属性上使用
		1映射实体类集合
			@OneToMany
				一对多映射
				//不用连接表时，基于外键
					@JoinColumn(name="PART_ID")	
						//注释的是另一个表指向本表的外键字段。另一表的PART_ID为外键，本表是一 
					<set name="parts">
						<key column="productSerialNumber" not-null="true"/>//另一个表指向本表的外键字段
						<one-to-many class="Part"/>			//被关联的类名
					</set>
				//用连接表时，基于连接表
					@JoinTable(name="tableName"	
							 JoinColumns={@JoinColum(name="persion")}		//本表主键在中间表中对应的字段
							 inverseJoinColum=@JoinColumn( name="PART_ID")//另一个表主键在中间表中对应的字段
							)	
						//注释的是另一个表指向本表的外键字段。另一表的PART_ID为外键，本表是一 
					<set name="parts" table="tableName">
						<key column="productSerialNumber" not-null="true"/>//另一个表指向本表的外键字段
						<one-to-many class="Part"/>			//被关联的类名
					</set>
			@ManyToMany
				多对多映射必用连接表，基于连接表
					@JoinTable(name = "Person_Project",  	//中间表名
					joinColumns = {@JoinColumn(name = "person_id")},  //本表主键在中间表中对应的字段，即外键
					inverseJoinColumns = {@JoinColumn(name = "project_id")}) //另一个表主键在中间表中对应的字段 
					<set name="parts" table="tableName">
						<key column="productSerialNumber"/>//另一个表指向本表的外键字段，外键
						<many-to-many class="Part"/>			//被关联的类名
					</set>	
		
			集合外键（foreign keys）
				@JoinColumn(nullable=false)					//指定表中的外键是哪个字段，通过外键取得关联的对象
				或
				<key column="productSerialNumber" not-null="true"/>	
				
			索引集合
				@OrderBy("name")	//按照集合类的name属性作索引
				@OrderColumn(name="orders_index")	//用持有集合索引值的字段的名称
		
		2映射基础类型集合和组件类集合
			值类型(组件集合必需用@CollectionTable来映射，集合默认是懒加载的，即在读取集合时才从数据库select，fetch属性决定抓去策略懒加载or立即加载
				1集合元素为基础值类型的映射
					@ElementCollection					//声明该集合是值类型的集合
					@CollectionTable(name="Nicknames", 		//声明中间表和外键
						joinColumns=@JoinColumn(name="user_id"))//不指定外键名时。默认外键字段名为 外键表_外键表的主键 user表的id为主键
					@Column(name="nickname")				//声明该集合在中间表对应的字段，将表中的该字段集合加入到java集合中
					
					附加：
						集合可以是set，collection，list
							set 的映射表中不存在重复项，set表通过userId与ItemName组合主键，保证每个用户的set集合不存在重复元素
								主键: userId与ItemName构成组合
								
							collection 可以存在重复的元素，即userId与ItemName相同的记录可以有多条，因此要为表添加一个额外主键
								@CollectionId（｛					//为collection添加一个主键，用以区分每条记录
									column=" PrimaryKey "，			//定义主键字段名
									type=@Type(type=“Long”)，			//定义主键的类型
									generator=identifier	//定义主键值生成策略,可用hibernate的Generator
								｝）
								主键: 主动为collection添加一个代理主键，使得可存在重复值
								
							list 可以保持元素在数据库中的顺序,所以表中要增加个索引字段，以user_id与索引作组合主键
								@OrderColumn				//在该list的表上添加一个索引字段，可以自定义字段名,默认是 表名_ORDER
								主键: user_id与索引字段字段构成组合主键
								
							Map 可以以键/值对的形式保存集合信息，在映射时要指定key字段
								@MapKeyColumn（name=“KEY_NAME”）		//指定key映射的列，默认为 表名_KEY 
								将map的键映射到表中的KEY_NAME列,同一用户的map的key不能重复，所以
								主键: 由user_id与Key_Name构成组合主键
							
				2集合元素的类型为组件类的映射( 组件也属于值类型  )
					@ElementCollection
					@CollectionTable(name="Addresses", joinColumns=@JoinColumn(name="user_id"))//中间表为Address，外键是user_id
						可选
							@AttributeOverrides({
							@AttributeOverride(name="street1", column=@Column(name="fld_street"))	
							})
							//重写组件属性映射的字段，组件类的street属性映射成中间表的fld_street字段，
							@AttributeOverrides用于重写多个属性
							@AttributeOverride用于重写单个属性
					一定要实现组件的相等性，重写equals()和hashCode()方法，便于set比较组件
					
					组件的集合与普通值的集合的配置方法相似
					同样的，组件集合也是set，collection,map,list
						set的组件集合依赖equals(),和HashCode()的实现，通常用业务键相等的方法重写equals()
						map
							若以某类组件为键key，则要重写某类的equals()和hashcode()方法，保证key是唯一的
					可通过@Parent引用组件构成的类的实例，使组件取得实体的引用，拥有对实体的单向关联
							
				xml方式
					不用<*ToMany>标签，换成<element>标签
						<key column>		//指明保存关联的表的外键
						<element			//指明保存关联的表的主键
							column(1)="column_name"
							formul(2)a="any SQL expression"
							type="(3)typename"
							length="L"
							precision="P"
							scale="S"
							not-null="true|false"
							unique="true|false"
							node="element-name"
					/>
		
		3高级
			集合排序sort
				@SortNatural	//使集合元素按自然排序
				或
				@hibernate.OrderBy(clause="FILENAME desc|asc")	//clause按指定的 列 的升序|降序 来排序,没有clause就按属性来排
				@OrderBy( " fieldName , desc|asc " )			//按组件属性名排序
				或
				@SortComparator(comparator.class)	//通过比较器排序
					
			双向关联 //双向关联允许通过关联的任一端访问另外一端
				在关联的两个类上都定意义*TO*
				一对多关联
					@OneToMany(MappedBy="d")		
						MappedBy==xml的inverse=true	//定义了作为反向端的实体
					或
					<bag name="categories" table="CATEGORY_ITEM" inverse="true">
							<key column="ITEM_ID"/>		
							<one-to-many class="Category" column="CATEGORY_ID"/>
					</bag>
				
				多对多关联		//必需定义中间表table="CATEGORY_ITEM"，不定义则隐式使用表
					@ManyToMany(cascade = CascadeType.PERSIST，mappedBy=“”)
						MappedBy==xml的inverse=true	//定义了作为反向端的实体
					或
					<bag name="categories" table="CATEGORY_ITEM" inverse="true">
							<key column="ITEM_ID"/>		
							<many-to-many class="Category" column="CATEGORY_ID"/>
					</bag>
	
	！关联关系映射
		0.简单的关联关系
			单向：
				在只在一端的实体类属性上@OneToMany,@ManyToOne,@OneToOne,@ManyToMany（fetch=fetchtypy.lazy）fetch属性配置抓取策略
				通过@JoinColumn指定外键
				
			使关联变双向
				在另一侧的实体类属性上@ManyToOne,@OneToMany,@OneToOne,@ManyToMany（fetch=fetchtypy.lazy）
				
				使用@OneToMany，@ManyToMany，@OneToOne的双向关联时，
				加上mappedBy属性，告诉hibernate使用另一侧 已给定属性映射的外键列 (@JoinColumn)来 select加载该关联
					表示当前实体由对面实体的mappedby的属性控制
				
			级联操作
				背景：
					双向关联 的两个对像a，b中，a添加b时，b要同时保存a，保证双方关联关系正确，即操作要可以传递
				jpa级联解决级联操作的传递问题
					通常在@OneToMany侧配置cascade属性，使操作可以级联起来，
					即a的属性上用了@OneToMany(cascade=CascadeType.persist),那么保存a时会级联保存b到数据库中
						cascadeType：
							cascadeType.persist		//级联保存	保存本侧时，先保存另一侧
							cascadeType.remove		//级联删除	hibernate会先加载集合实例，在对每个实例进行remove()操作，执行多条delete的sql，比较低效
												//hibernate对关联实体集合的删除是逐个删除的而组件集合是一次性删除的
							使用@OnDelete			//一次性删除集合,比remove高效
								hibernate的@OnDelet在数据库中执行一条on update cascade的ddl语言
								数据库中若在外键列定义了on update cascade，那么外键所在表的对应行被删除了，则拥有该外键的所有记录会被级联删除
								
				remove时可能出现不一致问题		//再次保存了被删除过的记录, 应用程序应负责移除被删除对象的引用
					a一对多b，b多对一c，
					若a删除了，a的b引用会在数据库被删除，
					但是，若c同时引用了b，在c update()时，被删除的b会随c的更新再次记录到数据库，b又出现在数据库中了！！导致数据不一致
					由于b也是实体，有自己的生命周期，可以被其他实体引用
		
		关于双向关联
			若b的fieldB 属性有 mappedBy“a.fieldA”，
			则当a的fieldA属性保存了b之后才能把ab关系持久化到数据库，
			若a.fieldA没保存过b，那么ab关系不会被存储到数据库，即使b.fieldB保存了a，也不能保存ab关
			
			因为b中的a是通过a中的b映射得到的，b中的a不能通过直接添加保存，只能通过a中加b再映射的到
			
		1.@OneToMany @ManyToOne		//若有基于外键，则外键必位于多侧
			@OneToMany：
				单向：		
					基于外键列：
						@JoinColum() 多的一方拥有外键保存关系，重写多的一方的基于本实体表的外键名
				(默认)基于中间表：	//此时的表有两个外键，没主键
						@JoinTable() 重写中间表的信息，name:重写表名，JoinColumn:重写本侧实体id在表中的外键名，inverseJoinColum:重写关联实体在表中的外键名
		  --------------双向：
		  |	   		基于外键列：2(默认)	
		  |				@Joincolumn 		//重写多的一方的基于本实体表的外键列名
		  |				或
		  |				在@OneToMany上添加mappedBy="human"属性，表示用本实体的id在另一侧human属性对应的外键列搜索，
		  |				从另一侧的表中取得若干行记录存放到被@OneToMany注解的集合中
		  |					@OnDelete 在外键上启用数据库的ON DELETE CASCADE，外键被删除时，多的那边的多条记录同时被删除
		  |  		基于中间表：
		  | 				只能配置mappedBy，通过另一侧取得 	//另一侧的属性 mappedBy与@JoinTable，@JoinColumn不可共存一侧
		  |  @ManyToOne		
		  |		单向：
		  |		(默认)基于外键列：			
		  |				@JoinColum()  		//多的一方拥有外键保存关系，本实体为多，重写本实体表上的外键名
		  |			基于中间表：	//此时的表有 两个外键，其中 多的一方作主键
		  | 				@JoinTable() 		//重写中间表信息
		  -------------双向：
					基于外键列：2(默认)	
						@Joincolumn 		//重写多的一方的基于本实体表的外键列名
					基于中间表：			//此时的表有 两个外键，其中 多的一方作主键即本侧是主键外键
						只能在多侧@JoinTable() 		//使用重写中间表的信息
						
			级联删除操作cascade不能在多的实体类中使用，否则有外键冲突
			
			在一的一方使用级联persist在保存一的那方前先保存多的那方
			
			实体集合排序
				OrderColumn(name="cloumn")	//指定按哪列排序
				OrderBy()	//OrderColumn会覆盖OrderBy()
		
		2.@OneToOne					//若有基于外键，则外键位于位于本侧
			单向：
			(默认)基于外键列：			//外键位于本侧
					@JoinColum()  		//本实体外键保存关系，重写本实体表上的外键名
					或
					@PrimaryKeyColumn	//或通过共享主键确定关联关系，外键=主键，表的主键取用外键的值
						本实体的主键与外键相同，引用的是关联实体的主键值
				基于中间表：			//此时的表有 两个外键，其中 本侧的外键作作主键
					@JoinTable() 		//重写中间表信息
					
			双向：
			(默认)基于外键列：			
					两边都@JoinColum()  		//外键位于本侧，两边同时拥有对方的外键
					或
					主控端mappedBy=“owner”	//通过另一端的外键取得另一端的实体，将取得的实体存放于被注解的这个变量
					被控端@JoinColum()		//这端拥有外键
					或
					主控端mappedBy=“owner”
					被控端@PrimaryKeyColumn	//被控端通过共享主键确定关联关系，外键=主键，表控表的主键取用外键的值
						同时被控端要把主键生成策略设置为“foreign”，parmaters添加一个属性:“property” 及value:“user”//user指外键的属性名
						本实体的主键与外键相同，引用的是关联实体的主键值
				X基于中间表：			//此时的表有 两个外键，其中 本侧的外键作作主键
					@JoinTable() 		//重写中间表信息	
					
		3@ManyToMany
			单向：
				基于中间表
					
			双向：
				基于中间表
					一侧@JoinTable
					另一侧mappedBy该侧只读取关系，不保存关系，被mappedBy的一侧即@JoinTable侧存储双方的关系
					
		4.更复杂的关联
			通过第3方中间实体类保存多元多对多关联
			或
			通过嵌入组件集合，在组件类上保存多元多对多关联
			1.三元关联、多元关联
				
			2.若希望中间表中不仅保存关联关系两端的主键，还想保存一些其他信息
				使用组件使关联更复杂
	
	！动态SQL生成 
		hibernate会在启动时，为crud预先创建好sql语句，加快执行效率，该语句包含表的所有列
		但在只修改某行的一个字段时，不需要对该行的所有的列都更新，只要对某个特定的字段更新，
		此时就不能用hibernate预先创建的sql语句了，而是根据改变的字段动态生成sql语句，生成一条只更新特定字段的sql
		
		当表中有非常多字段时使用动态sql更有效
		
		通过类的@DymanicInsert和@DynamicUpdata启用动态sql语句生成，
	
	!Inverse和Cascade的比较
		 Inverse：负责两个关联对象的控制关系
			决定谁控制谁的级联，false的一方作主控，true的一方被控
				若主控的一方被删除，被控的一方中所有与主控方有关的【外键字段】被清空赋值null
			用于集合属性上
			MappedBy="parent"	= inverse=true+@JoinColum	//通过child的parent属性构成childs集合，parent作为主控端
			或									//集合的元素通过相同的parent映射而来
			inverse=true|false
				如果false表示对集合的修改会反应到数据库中
				如果为true表示对集合的修改不会反应到数据库中（指定方向）
		 Cascade：负责控制关联对象的级联操作
			用在级联保存，级联更新，级联删除上
			
			决定主控一方的哪种操作会级联到被控一方
				若主控的一方被删除，被控的一方中所有与主控方有关的【记录】被整条删除
			级联删除(在OneToMany一端用)
				@OnDelete
				或
				<key column="productSerialNumber" on-delete="cascade"/>


			
EntityManager 	//持久化上下文~=session
	在spring中集成时的配置
		spring声明LocalEntityManagerFactoryBean或LocalContainerEntityFactoryBean的bean
		分别用于配置应用程序管理的JPA与容器管理的JPA
		应用程序管理的JPA
			JPA的配置信息由presistance.xml提供包括datasource，实体类等信息的配置，Spring配置时要设置对应的presistanceUnit名，
		容器管理的JPA
			JPA的配置信息由Spring提供，此时Spring担任容器的角色，为JPA提供所需的datasource及JPA实现，以及指定实体类的获取
			提供包括datasource等信息的配置，完全不用presistance.xml
	使用
		获得持久化上下文
			@PresistanceContext		//与spring集成时，@PresistanceContext不会注入真正的em，只是一个代理，通过代理的方法，使用em
			EntityManager em;
		或
		获得持久化单元
			@PresistanceUnit
			EntityManagerFactory emf
	缓存
		处于持久态的实体必定存在于在缓存中
		持久化上下文EntityManager会自动在内存中缓存所加载的持久化实体实例，可通过detach(i)手动将缓存的实例i回收。
		或用clear()将该持久化上下文的所有缓存的实例清除
	操作
		persist()
			持久化一个实例
		merge()
			将一个处于脱离态的实例i的修改更新到数据库，并产生一个持久态的实例b，实例i依然是脱离态的
		remove()
			移除一个处于持久态的实例，使该实例变成瞬时态
		find()
			查询获取一个持久态的实例，
			若持久化上下文中已有要查找的实例则直接在缓冲区取得该实例的引用
			否则从数据库查找
		flush()		实体实例------->数据库
			将缓存实体实例的修改手动同步到数据库，不用等到commit才同步，同时将同步后的实例从缓存中移除
		refresh()		实体实例<-------数据库
			加载好一个实体实例后，若其他人修改过该实例在数据库的数据，
			那么用refresh可以刷新该实体实例的所有引用的数据，用数据库的新数据覆盖实例数据
		detach(i)
			把在持久化上下文缓存的实体实例i从缓存中清除，使其变为脱离态，回收持久态实例
		clear()
			把在持久化上下文缓存的所有实体实例从缓存中清除，使其变为脱离态
		contains(i)
			检查实例i是否在缓存中，是否处于持久态
		getReference()
			
会话	
	Session本质为一个JDBC connection
	SessionFactory.getCurrentSession()
		会从CurrentSessionContext对象中取得连接，该连接由SessionContext管理，不用手动close
			sessionContext可以是Jta，Thread，managed分别由JTA，Thread，SessionManager来管理Session
			若没配置CurrentSessionContext，但配置了JTA事务，hibernate则会默认使用JTASessionContext来作为CurrentSessionContext的配置
		若配置了CurrentSessionContext为Thread
			SessionFactory会把当前当前java线程与一个Session对象绑定，调用getCurrentSession()时，会把当前线程绑定的Session对象返回
			cfg.xml中配置会话跟踪current_session_context_class 的值为thread 使session对象与在一条线程上活动，与一条线程绑定，
			通过线程本地变量ThreadLocal<map>将Session保存在当前线程中,并与SessionFactory关联起来，通过Map保存Session与SessionFactory的关联
		若配置了CurrentSessionContext为Jta
			SessionFactory会把当前jta的transaction与一个Session对象绑定，调用getCurrentSession()时，会把与当前线程所属的那条JTA事务绑定的Session对象返回
			使用JTACurrentSessionContext必需将hibernate.transaction.factory_class配置成JTATransactionFactory，使用JTA的事务，并正确配置JTA
			通过JTACurrentSessionContext中的Map将Session与当前事务关联，并让SessionFactory管理Session
	或
	SessionFactory.openSession()
		SessionFactory会从连接提供器(ConnectionProvider)中获得一个JDBC连接。此时Session由程序员来管理，要手动关闭close()
		若使用了连接池c3p0，ConnectionProvider就用C3p0的那一个
		
	session的生命周期
		当getCurrentSession()或openSession()获取一个session时，Session的生命周期开始
		当事务结束的时候，不管是提交还是回滚，Hibernate 会自动把 org.hibernate.Session 从当前线程剥离，并结束Session

加载实体
	若已知实体类的标志符id，可用session直接加载该实体对象，而不用查询；
	session.load(Human.class,id)		//若实体不存在throw 不可恢复异常
	or
	session.get(Human.class,id)		//若不存在，返回null；	
		可选LockMode
		
查询
	Hibernate 查询语言（HQL）		感觉就是SQL语句，不过有所不同 ：***
		命名参数(:var)
			在HQL的中用 ：param 使用命名参数，在Query中为命名参数赋值
			或者直接用？
		聚合方法
			avg(),count().max(),min(),sum()
			
	1.0.Hibernate标准查询 Criteria
		创建Criteria:
			session.creatCriteria()
		添加查询规则:
			Criteriaobj.add(Restrictions.eq(String,object))
			对标准的限制
				add(Restrictions类)
				Criteriaobj. add ( Restrictions.eq(String,object) )
			分页查询
				Criteria的setFirstResult（）与 setMaxResults
				或query的setFirstResult（）起始行与 setMaxResults返回的最大行数
			排序结果
				add(Order类)
				Criteriaobj. add ( Order.desc("salary"))
			预测与聚合 对应与HQL的聚合方法
				Projections类
				Criteriaobj. setProjection ( Projections.avg("salsry"))
		获取查询结果
			cr.list()
		用于创造与执行面向规则的对象 来查询对象
	或
	1.0.JPA标准查询
		1CriteriaBuilder			//取得条件建造器
			CB=session.getCriteriaBuilder()
			或
			em.getCriteriaBuilder()
		2CriteriaQuery			//创建条件查询
			CQ=CB.createQuery();
		3.Root<T>查询根			//构造目标实体用查询根代表 why?构建查询条件时可以取得目标实体的各种信息用作条件选择的表达式
			Root<T> r=CQ.from(T.class);
				Root信息
					type()：Root代表的实体的类				//T.class,
					get("name")：Root代表的实体的属性name		//name属性的类型
										
		4.Select				//构造一条获取查询根所代表的实体的select语句
			CQ.select（column1，column2）的入参是要取得的列
				select[ column1，column2 ,..]from human；
				
			投影:想要返回的列
				CQ=CQ.select(r);	
				或	
				CQ.multiselect(Root1,Root2)				//表示 select h,b from human h,book b;
					会产生Root1与Root2的笛卡尔积，返回的是元组，且元组每个元素是持久化的实体实例
				CQ.multiselect(Root.field1,Root.field2,Root.field3)	//表示 select h.id,h.name,h.age from human h;
					返回的一定是元组且元组的元素全是瞬时的，不可被持久化
				或
				CQ.select(CB.Tuple（Root1,Root2）)
			
			由于投影的出的不是一个实体,必需要用元组接受结果
				多个列
					List<Object[]>
				单个结果
					Object[]
			
			动态实例化DTO		//投影的到的那些列用一个非实体类表示
				DTO数据传输对象，只用来传输数据而不用来持久化的对象
				希望将要投影的那些列映射到一个非实体类的属性上，不定义实体类来取得查询结果
					JPQL : select new MySummary( h.id,h.name,b.title ) from human h,book b;	//动态实例化
						MySummary 要有一个有参构造函数
						动态 : 查询结果得到的实例不是事先定义好映射的实体类，而是普通的不带@Entity的java类
					或
					条件化查询
						CQ.select(CB.Constructor( MySummary.class,arg0,arg2,arg3 ))
				若DTO没有构造函数，则使用resultTransformer将结果动态实例化为DTO
				
			得到唯一结果 
				select distinct h,name from human h;
				or
				CQ.distinct(true)
			
			在投影中调用函数
				CQ.select（CB.concat(arg1,arg2)）
				or
				select concat(h.name,":",h.id) from human h;
			
			聚合函数
				count(),sum(),min(),max(),avg()
				特殊的JPQL函数 CB.countDistinct(Root) 会忽略重复值
				or
				select count（distinct h.name）from human;
				
			分组
				分组函数要配合聚合函数使用
				CQ.GroupBy(Root)
				or
				。。。 Group by column;
			
			分组过滤（根据限制条件过滤分组）				从分组后的数据列上设置条件
				对分组后的记录筛选，predict是分组后关于列的限制条件,而where是原始记录进行筛选
					CQ.having(Predicate)
				Croup By i having 	
			
			联结查询
				通过一次查询的到关系表及其关联的其他表
					on 指定联结条件
				内联查询		// inner 表示每行的 h.id 与 m.id 都一一对应
					select * from human as h inner join man as m on m.id=h.id;
				
				外联查询一定要用on
				左外联查询		// left outer 表示每行的 左边的 h.id 不可有空，右边的 m.id 可以有空
					select * from human as h left outer join man as m on m.id=h.id;
					
				右外联查询		// right outer 表示左边表的记录可以为空，右边表的每行都不可空
					select * from human as h left outer join man as m on m.id=h.id;
			
			子查询
				where exists（subselect）
				量化
					any，all，exists 
					
			Row value 构造函数语法
				一次性对多列进行比较
					where not ( cat.name, cat.color ) in (
							select cat.name, cat.color from DomesticCat cat
						)
			
		5.where				//为查询添加条件如id>0....  在原始数据的所有列上设置条件
			CQ.where(id>0)	的入参是条件
				select * from human where[ id>0 ,..];
			CQ.where(Condition)
			
		6.Predicate（Condition）限制
			由CriteriaBuilder CB的方法给出的条件运算,用作where参数 
				equal	 between	gt  greaterThan  in  isNull  	isNotNull    like
				=	 between	>   >		 in  is null  	is not null	  like
				(equal,=) (between,between) (gt,>) (greaterThan,>) (in,in) (isNull,is null) (isNotNull,is not null)
			限制
				比较表达式
					CB.equal(Root信息，限定值)		//如equal（r.type,"value"）,	表示where type(r)="value" r的类型为value
					CB.between(Root信息,下限值,上限值)// between(r.get("id"),1,100)	,	表示where id between 1 and 100
					CB.gt(Root,value)				// 表示where Root>value   仅仅可以比较数字类型
					CB.greaterThan(Root,value)		// 表示where Root>value   可以比较非数字类型 如:Data
					CB.in(Root,value1,value2)		// 表示where Root in ("value1"，"value2")	
					CB.like(Root,"_value%")			// 表示where root like “_value%”
					CB.isNull(Root)				// where root is null
					not(predicate) and(predicate,predicate) or(predicate,predicate)	//逻辑操作符
				集合表达式
					isEmpty(Root.Collection)		//若实体的某个属性是集合属性，isEmpty（Root.<Collection>get("Itemss")）,判断集合是否空
					isNullEmpty()				//where Root.itemss is not empty
					
				在条件中调用函数
					length(),size(),concat(),upper(),lower().

		7.order 排序
			CQ.orderBy(CB.asc(root)|CB.desc(root))
			
		9.Query(取得查询)
			Q=session.createQuery(CQ);
		
		select 
			[function()|column|subselect]+ 
		from table1 
			[[join | left outer join | right outer join] table2 on [predicate]]*
		[where [predicate[function()|column] | subselect]+]? 
			[Group by [Cloumn|function()]+ [Group by [cloumn|function()]+]? ]?
			[Order by [column|function()]+ [desc|asc]?]?
	或	
	1.1简单查询(createQuery(JPQL))
		类型化查询(准备)
			JPA的type query
				TypeQuery<T> q=em.createQuery（‘sql’，T.class）	//sql为HQL/JPQL/SQL语言，通过T.class指定类型，通过安全检查
			或
			hibernate的query
				hibernate.query.Query<T> q=session.createQuery（‘sql’，T.class）	//sql为HQL/JPQL/SQL语言，通过T.class指定类型，通过安全检查
			
			命名参数
				sql中的:name
					通过setParameter('name',name) 把name的值绑定到‘name’上，防止sql注入
			定位参数
				sql中的?1,?2
					通过setParameter(1,name) 把name的值绑定到?1位置上，防止sql注入
	或
	1.2外部命名查询(手动预先编写复杂的sql语句，通过名字直接调用)
		命名与外部查询
			调用命名查询
				JPA
					typequery em.createNamedQuery（“queryName”，T.class）
				Hibernate 
					session.getNamedQuery（“queryName”）
					session.createNamedQuery（“queryName”，T.class）
			定义命名查询
				在xml元数据中定义(即或hibernate的映射文件hbm.xml)
					JPA	query.xml
						<entity-mappings>
							<entity >
							<name-query name="name">						//JPQL
								<query><![CDATA[ JPQL ]]></query>
							或
							<name-native-query name="name" result-class="*.*.T">	//SQL
								<query><![CDATA[ sql ]]></query>
								
					hibernate	query.hbm.xml
						要在query返回的实体类的映射文件中定义，如果实体通过注解定义的就通过注解定义命名查询
						<hibernate-mapping>
							<class name="huamn"/>
								....
							<query name="name"> JPQL </query>				//不用指定实体类
							或
							<sql-query name="name"> 
								<return class="*.*.T"/>						//用sql时要指明实体类
								SQL </>			

				用注解定义查询
					1.JPA方式
						在Entity类上
						@NamedQueries(
								@NamedQuery(name="queryname", query="JPQL/HQL")
						or
						@NamedNativeQueries(
								@NamedNativeQuery(name="queryname", query="SQL")
								)
				编程定义命名查询
					在Session中addNamedQuery（“name”，Query）
					或
					在emtitymanager取得entityManagerFactory并addNameQuery（，）
	
	返回Tuple的查询
		若查询返回的每条记录包含多个实体类，可用元组（Object[]）接受返回，此时Object数组中的每个元素都是实体类
		倘若有多条记录可用List<Object[]> 接受返回的结果集
	
	返回标量（scalar）
		同样用object[]接受查询结果，但查询的结果不能构成实体类，此时Object[]的每个元素是标量
		标量即不能构成实体的元素
	
	返回动态实例
		使用JPQL查询，用返回的标量构成一个非实体类的实例
			select new package.DynamicClass(h.id,h.name,b.title) from human h,book b;
				返回DynamicClass的实例化对象，注意，他有有参构造函数DynamicClass（Long，String，String）
				要用全限定类名
	
	2分页查询(设置分页)
		query.setFirstResult(10)		//设置从第10行开始取得结果
		query.setMaxResult(40)		//设置每次取得40行结果
		或
		用数据库游标cursor
	
	3执行查询
		得到所有结果
			q.getResultList()		//没结果就返回空list
			
		得到单个结果
			q.getSingleResult()	//若没结果throw NoResultException,若返回不止一个结果throw NoUniqueResultException
			
	遍历结果
		使用迭代器iterator
	
	原生SQL语言查询

自定义实体类的加载，创建，更新，删除
	1自定义实体类的加载SQL
		实体类上hibernate的@Loader(namedQuery="NativeQuery")
		将通过自定义的命名查询"NativeQuery"的结果加载目标实体
	2.自定义insert，updata，delete
		实体类上@SQLInsert，@SQLUpdate，@SQLDelete
		sql属性为自定义sql语句
				
映射标准SQL查询(NativeQuery)的结果
	映射的结果有3种
		1.实体类entityresult
		2.非实体类constructor-result
		3.单纯的标量column
	xml		//定义在NativeQuery.xml中
		<sql-result-set-mapping name=“NAME”>			//定义映射的名子，通过名字应用映射
			<entity-result entity-class=“*.*.User”>		//SQL查询结果映射为User实体
				<field-result name=“id” column="ID">	//指定结果中的列映射到实体类字段
				....
			<constructor-result target-class=“*.*.sumary”>	//SQL查询结果映射为有构造器的普通POJO类-sumary
				<column name="ID" class="Long">	//指定构造器参数映射的列
				....
			<column name=“NUM_BER”>				//将结果中的某列映射为标量Object
	注解
		在实体类上				//@ColumnResult(name="lie") 引用结果中的列,name指定列名，用于标量和构造器的结果列映射
							//@FieldResult(name="ddd")	引用结果中的列,name指定列名，用于实体类的列-属性映射
		@SqlResultSetMapping(name="mapname",
						entities={
							@EntityResult(
								entityClass,fields )},	//至少指定entityClass
						classes={
							@ConstructorResult(
								targetClass,columns )},	//至少指定targetClass
						columns={
							@ColumnResulr(name="")})	//至少指定name
	
		混合实体，非实体，标量映射时，通过元组（Object[]）取得结果,Object[]的元素代表每个sql映射
		
	使用JPA规范进行SQL查询
		em.createNativeQuery("SQL"，"resultSetMapping"),还可以添加参数指定sql结果集映射使用上面定义的映射
		
hibernate抓取策略
	延时加载
		通过代理proxy的方式，延迟关联实体的加载，只有在关联实体被调用时才从数据库查询。
			持久化上下文持有一个目标实体的代理类，调用目标实体时，被代理类拦截并向数据库查询结果
			对一关联
				默认用急加载即 @*ToOne(fetch=FetchType.Eager)
				OneToOne必需设置为option=false 才可用代理来进行懒加载
			对多关联和组件集合
				默认是懒加载即 @*ToMany(fetch=FetchType.Lazy)
				
				集合的额外懒加载配置
					@LazyCollection(EXTRA)
					可以在不查询集合中所有结果的情况下，取得集合的元素个数，用Count()来取得元素个数
		通过拦截器的方式进行懒加载
			1.先在实体类上@Proxy(lazy=false)关闭代理的懒加载
			
		使用延时加载问题
			n+1问题
				若要遍历实体所关联的实体集合时，1条select用于取得本实体记录，另外再用n条select语句取得被关联的实体的集合
		
	急加载
		FetchType.Meger
		
		使用急加载问题
			笛卡尔积问题n*n
				用一条select语句，一次性把所有关联的实体加载起来，会产生多余的记录，加大数据库内存的消耗。
				1-n-m		加载1个实体，并会加载n个直接关联的实体，n个实体又会加载与之关联的m个实体，
						select语句用joins来连接这些关联查询，导致n*m的笛卡尔积查询，在数据库内存中加载n*m条记录
						
	动态急抓取(执行jpql时决定抓取方式)
		1.动态急抓取会忽略在映射中定义的抓取策略，@Fetch
		2.动态急抓取
		JPQL中使用fetch关键字，通过left join fetch的方式动态抓取原本被懒加载的集合属性
		或
		使用标准查询时
			通过Root的fetch(“propertyName”,JoinType.LEFT)实现动态抓取
	
	批量抓取(折中解决以上问题)
		设置每次抓取批量大小
			懒加载
				在实体类a上@BatchSize（size=10）	,当a第一次被使用，便会一次性加载10条a的实例，当第11个a被使用，又再加载10个实例
				或
				在集合上@BatchSize（size=10）
			
实体的抓取策略
	实体加载时机(FetchType)
		懒加载集合
			在映射集合时将lazy属性配置为true
				<set name="orders" inverse="true" lazy="true">
				@*ToMany(fetch=FetchType.Lazy)
		懒加载实体
			在配置实体映射文件时将lazy属性配置为true
				<class name="orders" lazy="true">
				@*ToOne(fetch=FetchType.Lazy)
	实体抓取方式(FetchMode)
		通过left outer join抓取集合
			设置集合映射标签的fetch属性为join
			<many-to-one name="classes" column="classesid" fetch="join"/>
			@Fetch（FetchMode.Join）
			此时lazy会失效  

		另外发送一条select语句抓取当前对象关联实体或集合  
			fetch=“select”
			<many-to-one name="classes" column="classesid" fetch="select"/>
			@Fetch（FetchMode.select）
			
		通过subselect抓取集合
			设置集合映射标签的fetch属性为subselect
				<many-to-one name="classes" column="classesid" fetch="subselect"/>
				@Fetch（FetchMode.Subselect）
			
		每次抓取实体的批量
			设置batch-size大小
				设置了batch-size后，每次加载batch-size个实体，
				<class name="orders" batch-size=5>
				<set name="orders" inverse="true" batch-size=5>			
				@BatchSize
			
通过拦截器侦听实体的操作，实现审计日志追踪
	用JTA拦截器
		1定义一个侦听类
			@PostLoad@PrePersist，@PostPersist@PreUpdate@PostUpdate@PreRemove@PostRemove
			分别定义对不同实体类操作的回调方法
		2.使用侦听器
			在实体类上@EntityListeners(listener.class)
	用hibernate拦截器（**）
		hibernate拦截器可进行粒度更细的拦截，用于记录操作
		1实现hibernate.interceptor接口或继承EmptyInterceptor
		2.在配置文件中配置"hibernate.ejb.interceptor"属性为interceptor接口的实现类或用Configuration.setInterceptor()
				
缓存
	有一级缓存与二级缓存，都存在于内存或硬盘
	默认下，Hibernate 将缓存所有的在会话层缓存中的持久的对象
	一级缓存
		保存在Session里的缓存，是一级缓存，是必需有的缓存，缓存只在当前Session有效
	二级缓存
		用第三方提供的缓存管理，是可选的缓存，
		第二级缓存可以在每一个类和每一个集合的基础上被安装，并且它主要负责跨会话缓存对象。 
		
		hibernate本身只提供二级缓存的规范，有第三方插件做具体实现。EHCache 
		
		Hibernate 配置二级缓存通过两步设置
			0.设置EHCache.xml配置文件
			1.在配置文件hibernate.cfg.xml中	配置二级缓存提供者
				h4前
				<property name="hibernate.cache.provider_class">
				  org.hibernate.cache.EhCacheProvider		//缓存提供者
			   </property>
				h4后
				<property name="hibernate.cache.region.factory_class">
					
			2.激活二级缓存
				<property key="hibernate.cache.use_second_level_cache">true</prop>
				
			3.指定在那个实体类上用二级缓存
				<class-cache usage="read-only" class="Human"/>
			
	使用缓存
		1.使用配置文件中的 hibernate.cache.use_query_cache="true" 属性 	
			<property name="hibernate.cache.use_query_cache">true</property>
				激活查询层次缓存
				使用查询缓存:Query 类的 setCacheable(Boolean)
		2.在配置文件中决定好使用哪个并发策略
			缓存策略
				Read-only 
				Nonstrict-read-write 	
				Read-write 	
				Transactional
			在映射文件中配置<cache usage="read-write">	//在映射文件中配置
				表示使用并发策略  read-write
					<cache 
						usage="transactional|read-write|nonstrict-read-write|read-only"
						region="RegionName"
						include="all|non-lazy"/>
				或
				注解方式
					实体类上@Cacheable为实体类启用共享缓存
					@Cache（usage=。。）配置该实体类的缓存策略
					在实体类的标志属性上@natureId作为该实体在缓存区的标识符，通过该标志符查找缓存
					//在加载实体时缓存实体
		
	
	使用二级缓存时机
		1.更新频率低的实体
		2.不会被更改的实体
		3.数据状态稳定的实体
		4.不被其他应用共享的数据
		5.容忍少量并发访问的数据
		
批处理
	启用批处理
		配置文件中配置每批大小
			<property name="hibernate.jdbc.batch_size">50</property> 
				告诉 hibernate 容器每 50 行sql语句为一批插入，删除，更新数据库
			
			hibernate.jdbc.fetch_size
				Fetch Size 是设定JDBC的Statement读取数据的时候每次从数据库中取出的记录条数
				合理配置，可减少对数据库的读取，加快了速度
		程序中
			每50条记录就执行一次session.flush() 和 session.clear()，防止缓存区爆满
			
		flush()
			将缓存区的缓存写入数据库
		clear()
			清空缓存区
		
	hibernate.jdbc.fetch_size 50 //读 读取时，每次从数据库取50条查询记录，50性能显著提升，100为提升阀值，》100无明显提升
	hibernate.jdbc.batch_size 30 //写 UCD操作时批量删除，批量更新和批量插入的时候的批次大小，每30条sql向数据库发送一次
		CUD 操作时Hibernate都会往二级缓存充入相应的数据。性能上就会有很大损失，建议在批处理情况下禁用二级缓存。
		
拦截器
	在session对数据库操作时，对其各个阶段进行拦截，一个可能的用途，就是用来跟踪审核（auditing）信息。
	1通过直接实现 Interceptor 接口或者继承 EmptyInterceptor 类，使用拦截器
	2.在cfg.xml中配置hibernate.ejb.interceptor属性指定interceptor类
		或在sessionFactory.setInterceptor(interceptor)	//此interceptor的范围是属于SessionFactory的
	或
	openSession（interceptor）	//在一个session范围内定义一个interceptor
	或
	或用Configuration.setInterceptor()	//配置拦截器
	3进行查询，拦截器会拦截到每个阶段的动作，并做出反应
	
session事件	
	session的每个方法都会激发一个事件，如load()：LoadEvent，这些事件可以被对应的事件监听器接收到并做出反应
	可作为拦截器的辅助工具
	自定义事件监听器
		1实现相应的事件监听器接口
			如：LoadEventListener
		2.配置监听器
			Configuration.EventListeners().setLoadEventListener({ Listener })
			或
			<session-factory>
				<event type="Load">
					<listener class="listener">
	